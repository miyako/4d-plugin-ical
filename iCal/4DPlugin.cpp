/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : iCal
 #	author : miyako
 #	2016/10/03
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


#pragma mark -

const char *sql_get_calendar_group_uid = "SELECT\n\
ZUID\n\
FROM ZNODE\n\
WHERE Z_PK ==\n\
(\n\
 SELECT ZGROUP\n\
 FROM  ZNODE\n\
 WHERE ZUID == ?\n\
 LIMIT 1\n\
 );";

const char *sql_get_calendars = "SELECT\n\
ZUID, ZTITLE\n\
FROM ZNODE\n\
WHERE ZISTASKCONTAINER != 1\n\
AND ZGROUP != '';";

void sqlite3_get_calendar_group_uid(NSString *userCalendarPath,
																		CUTF8String &calendar_uid,
																		CUTF8String &group_uid)
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		sqlite3 *sqlite3_calendar = NULL;
		
		int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
		
		if(err != SQLITE_OK)
		{
			NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
		}else
		{
			sqlite3_stmt *sql = NULL;
			err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendar_group_uid, 1024, &sql, NULL);
			if(err != SQLITE_OK)
			{
				NSLog(@"failed to prepare sqlite statement");
			}else
			{
				sqlite3_bind_text(sql, 1, (const char *)calendar_uid.c_str(), calendar_uid.length(), NULL);
				
				while(SQLITE_ROW == (err = sqlite3_step(sql)))
				{
					const unsigned char *_group_uid = sqlite3_column_text(sql, 0);
					if(_group_uid)
					{
						group_uid = CUTF8String(_group_uid, strlen((const char *)_group_uid));
					}
				}
				sqlite3_finalize(sql);
			}
			sqlite3_close(sqlite3_calendar);
		}
		[l unlock];
	}
	[l release];
}

void sqlite3_get_calendars(NSString *userCalendarPath,
													 ARRAY_TEXT &uids,
													 ARRAY_TEXT &titles)
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		sqlite3 *sqlite3_calendar = NULL;
		
		int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
		
		if(err != SQLITE_OK)
		{
			NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
		}else
		{
			sqlite3_stmt *sql = NULL;
			err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendars, 1024, &sql, NULL);
			if(err != SQLITE_OK)
			{
				NSLog(@"failed to prepare sqlite statement");
			}else
			{
				while(SQLITE_ROW == (err = sqlite3_step(sql)))
				{
					const unsigned char *_calendar_uid = sqlite3_column_text(sql, 0);
					const unsigned char *_title = sqlite3_column_text(sql, 1);
					
					if(_calendar_uid)
					{
						if(_title)
						{
							uids.appendUTF8String(_calendar_uid, strlen((const char *)_calendar_uid));
							titles.appendUTF8String(_title, strlen((const char *)_title));
						}
						
					}
				}
				sqlite3_finalize(sql);
			}
			sqlite3_close(sqlite3_calendar);
		}
		[l unlock];
	}
	[l release];
}

#pragma mark -

namespace CalendarWatch
{
	
	class UserInfo
	{
	private:
		
		notification_t _notification;
		CUTF8String _uid;
		method_id_t _method;
		
	public:
		
		UserInfo(notification_t notification, NSString *event_uid, method_id_t method);
		
		void get(notification_t *notification, CUTF16String &event, method_id_t *method);
		
		~UserInfo();
	};
	
	UserInfo::UserInfo(notification_t notification, NSString *event_uid, method_id_t method)
	{
		this->_notification = notification;
		if(event_uid)
		{
			this->_uid = CUTF8String((const uint8_t *)[event_uid UTF8String]);
		}
		this->_method = method;
	}
	
	void UserInfo::get(notification_t *notification, CUTF16String &event, method_id_t *method)
	{
		*notification = this->_notification;
		
		*method = this->_method;
		
		C_TEXT t;
		t.setUTF8String(&this->_uid);
		t.copyUTF16String(&event);
	}
	
	UserInfo::~UserInfo()
	{
		
	}
	
	const process_stack_size_t stachSize = 0;
	const process_name_t processName = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0_\0W\0A\0T\0C\0H\0\0\0";
	
	std::map<CUTF8String, method_id_t> paths;
	std::vector<UserInfo> notifications;
	
	FSEventStreamRef eventStream = 0;
	NSTimeInterval latency = 1.0;
	process_number_t monitorProcessId = 0;
	bool processShouldTerminate = false;
	
	method_id_t getMethodId(NSString *path_ns)
	{
		@autoreleasepool
		{
			NSString *monitorPath_ns = [path_ns stringByDeletingLastPathComponent];
			CUTF8String monitorPath = CUTF8String((const uint8_t *)[monitorPath_ns UTF8String]);
			monitorPath += (const uint8_t *)"/";
			//global variables: CalendarWatch::paths
			NSLock *l = [[NSLock alloc]init];
			if ([l tryLock])
			{
				auto i = paths.find(monitorPath);
				if (i != paths.end())
				{
					return i->second;
				}
				[l unlock];
			}
			[l release];
		}
		return 0;
	}
	
	void gotEvent(FSEventStreamRef stream,
								void *callbackInfo,
								size_t numEvents,
								void *eventPaths,
								const FSEventStreamEventFlags eventFlags[],
								const FSEventStreamEventId eventIds[]
								)
	{
		//global variables: CalendarWatch::notifications
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			@autoreleasepool
			{
				NSArray *paths_ns = (NSArray *)eventPaths;
				NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"([:HexDigit:]{8}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{12})\\.ics$"
																																							 options:NSRegularExpressionCaseInsensitive
																																								 error:nil];
				if(regex)
				{
					for(NSUInteger i = 0; i < numEvents; ++i)
					{
						NSString *path_ns = [paths_ns objectAtIndex:i];
						
						NSArray *matches = [regex matchesInString:path_ns
																							options:0
																								range:NSMakeRange(0, [path_ns length])];
						
						for (NSTextCheckingResult *match in matches)
						{
							NSString *event_uid = [path_ns substringWithRange:[match rangeAtIndex:1]];
							FSEventStreamEventFlags flags = eventFlags[i];
							method_id_t methodId = getMethodId(path_ns);
							NSLog(@"flags:%d", (unsigned int)flags);
							if(methodId)
							{
								if((flags & kFSEventStreamEventFlagItemRemoved) == kFSEventStreamEventFlagItemRemoved)
								{
									NSLog(@"removed calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_delete, event_uid, methodId);
									notifications.push_back(userInfo);
								}
								else if((flags & kFSEventStreamEventFlagItemCreated) == kFSEventStreamEventFlagItemCreated)
								{
									NSLog(@"created calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_create, event_uid, methodId);
									notifications.push_back(userInfo);
								}
								else
								{
									NSLog(@"modified calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_update, event_uid, methodId);
									notifications.push_back(userInfo);
								}
							}
						}
					}
				}
			}//@autoreleasepool
			listenerLoopExecute();
			[l unlock];
		}
		[l release];
	}
	
	void endMonitor()
	{
		//global variables: CalendarWatch::eventStream
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			if(eventStream)
			{
				FSEventStreamStop(eventStream);
				FSEventStreamUnscheduleFromRunLoop (eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
				FSEventStreamInvalidate(eventStream);
				FSEventStreamRelease(eventStream);
				eventStream = 0;
				NSLog(@"stop monitoring paths");
			}
			[l unlock];
		}
		[l release];
	}
	
	void startMonitor()
	{
		FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
		
		NSMutableArray *paths_ns = [[NSMutableArray alloc]init];
		//global variables: CalendarWatch::paths
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			for(std::map<CUTF8String, method_id_t>::iterator it = CalendarWatch::paths.begin(); it != CalendarWatch::paths.end(); it++)
			{
				CUTF8String path = it->first;
				NSString *path_ns = [[NSString alloc]initWithUTF8String:(const char *)path.c_str()];
				if(path_ns)
				{
					[paths_ns addObject:path_ns];
					[path_ns release];
				}
			}
			[l unlock];
		}
		
		endMonitor();
		
		listenerLoopStart();
		
		if([paths_ns count])
		{
			if ([l tryLock])
			{
				eventStream = FSEventStreamCreate(NULL,
																					(FSEventStreamCallback)gotEvent,
																					&context,
																					(CFArrayRef)paths_ns,
																					kFSEventStreamEventIdSinceNow,
																					(CFAbsoluteTime)latency,
																					kFSEventStreamCreateFlagUseCFTypes
																					| kFSEventStreamCreateFlagFileEvents
																					| kFSEventStreamCreateFlagNoDefer
																					| kFSEventStreamCreateFlagIgnoreSelf
																					);
				NSLog(@"start monitoring paths:%@", [paths_ns description]);
				FSEventStreamScheduleWithRunLoop(eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
				FSEventStreamStart(eventStream);
				
				[l unlock];
			}
			[l release];
			
		}
		[paths_ns release];
	}
	
	bool isInWatch(CUTF8String &path)
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			auto i = paths.find(path);
			return (i != paths.end());
			[l unlock];
		}
		[l release];
		
		return false;
	}
	
	void addToWatch(CUTF8String &path, method_id_t methodId)
	{
		if (!isInWatch(path))
		{
			NSLock *l = [[NSLock alloc]init];
			if ([l tryLock])
			{
				paths.insert(std::map<CUTF8String, method_id_t>::value_type(path, methodId));
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
				[l unlock];
			}
			[l release];
		}
	}
	
	void removeFromWatch(CUTF8String &path)
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			paths.erase(path);
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
			if(!paths.size())
			{
				listenerLoopFinish();
			}
			[l unlock];
		}
		[l release];
	}
	
	void removeAllFromWatch()
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			paths.clear();
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)endMonitor, NULL);
			listenerLoopFinish();
			[l unlock];
		}
		[l release];
	}
	
}

#pragma mark -

bool isProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void onCloseProcess()
{
	if(isProcessOnExit())
	{
		CalendarWatch::removeAllFromWatch();
	}
}

void onStartup()
{
	
}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

void listenerLoop()
{
	CalendarWatch::monitorProcessId = PA_GetCurrentProcessNumber();
	NSLog(@"%@", @"listenerLoop:start");
	
	NSLock *l = [[NSLock alloc]init];
	
	while((!CalendarWatch::processShouldTerminate) && !PA_IsProcessDying())
	{
		PA_FreezeProcess(PA_GetCurrentProcessNumber());
		PA_YieldAbsolute();
		
		//global variables: CalendarWatch::notifications,processShouldTerminate
		if ([l tryLock])
		{
			if(!CalendarWatch::processShouldTerminate)
			{
				if(CalendarWatch::notifications.size())
				{
					C_TEXT processName;
					generateUuid(processName);
					PA_NewProcess((void *)listenerLoopExecuteMethod,
												CalendarWatch::stachSize,
												(PA_Unichar *)processName.getUTF16StringPtr());
				}
			}
			[l unlock];
		}
	}//while(!CalendarWatch::processShouldTerminate)
	CalendarWatch::monitorProcessId = 0;
	
	PA_KillProcess();
	NSLog(@"%@", @"listenerLoop:end");
	[l release];
}

void listenerLoopStart()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		if(!CalendarWatch::monitorProcessId)
		{
			CalendarWatch::processShouldTerminate = false;
			PA_NewProcess((void *)listenerLoop,
										CalendarWatch::stachSize,
										CalendarWatch::processName);
		}
		[l unlock];
	}
	[l release];
}
 
void listenerLoopFinish()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		CalendarWatch::processShouldTerminate = true;
		PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
		[l unlock];
	}
	[l release];
}

void listenerLoopExecute()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		CalendarWatch::processShouldTerminate = false;
		PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
		[l unlock];
	}
	[l release];
}

void listenerLoopExecuteMethod()
{
	//global variables: CalendarWatch::notifications
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		if(CalendarWatch::notifications.size())
		{
			std::vector<CalendarWatch::UserInfo>::iterator it = CalendarWatch::notifications.begin();
			
			CalendarWatch::UserInfo userInfo = *it;
			
			notification_t notification;
			CUTF16String eventId;
			method_id_t methodId;
			
			userInfo.get(&notification, eventId, &methodId);
			
			PA_Variable	params[2];
			
			params[0] = PA_CreateVariable(eVK_Unistring);
			params[1] = PA_CreateVariable(eVK_Longint);
			
			PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
			PA_SetStringVariable(&params[0], &event);
			PA_SetLongintVariable(&params[1], notification);
			
			CalendarWatch::notifications.erase(it);
			
			PA_ExecuteMethodByID(methodId, params, 2);
			
			PA_ClearVariable(&params[0]);
			PA_ClearVariable(&params[1]);
		}
		[l unlock];
	}
	[l release];
}

namespace iCal
{
	RecordSpecifier recordSpecifier;
	RecordSpecifiers recordSpecifiers;
	C_TEXT listenerMethodName;
	
	NSString *copyAttendeesDictionary(NSArray *attendees){
		NSString *attendeesData = nil;
		
		if(attendees)
		{
			CalAttendee *attendee = nil;
			
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			NSMutableArray *array = [[NSMutableArray alloc]init];
			
			unsigned int i;
			
			for (i = 0; i < [attendees count]; i++)
			{
				if([[attendees objectAtIndex:i]isMemberOfClass:[CalAttendee class]])
				{
					attendee = [attendees objectAtIndex:i];
					
					NSString *addressString = nil;
					if(attendee.address)
					{
						addressString = [attendee.address absoluteString];
					}else{
						addressString = @"";
					}
					
					NSString *statusString = nil;
					if(attendee.status)
					{
						statusString = attendee.status;
					}else{
						statusString = @"";
					}
					
					NSString *commonNameString = nil;
					if(attendee.commonName)
					{
						commonNameString = attendee.commonName;
					}else{
						commonNameString = @"";
					}
					
					NSDictionary *item = [NSDictionary
																dictionaryWithObjects:[NSArray arrayWithObjects:statusString, commonNameString, addressString, nil]
																forKeys:[NSArray arrayWithObjects:@"status", @"commonName", @"address", nil]];
					
					[array addObject:item];
					
				}
				
			}
			
			[dictionary setObject:array forKey:@"attendees"];
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			attendeesData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			
			[array release];
			[dictionary release];
			
		}else{attendeesData = @"";}
		
		return attendeesData;
	}
	
	NSArray * getCalendars(CalCalendarStore *calendarStore, NSArray *calendarNames, C_LONGINT &returnValue){
		NSArray *calendars = [calendarStore calendars];
		NSMutableArray *foundCalendars = [NSMutableArray array];
		CalCalendar *calendar;
		unsigned int i, j;
		for(i = 0; i < [calendarNames count]; ++i){
			calendar = [calendarStore calendarWithUID:[calendarNames objectAtIndex:i]];
			if(calendar){
				[foundCalendars addObject:calendar];
			}else{
				for(j = 0; j < [calendars count]; ++j){
					calendar = [calendars objectAtIndex:j];
					if([calendarNames containsObject:[calendar title]]){
						[foundCalendars addObject:calendar];
					}
				}
			}
		}
		
		if(![foundCalendars count]){
			returnValue.setIntValue(ERROR_CALENDAR_NOT_FOUND);
		}
		
		return foundCalendars;
	}
	
	NSArray * getCalendars(CalCalendarStore *calendarStore, ARRAY_TEXT &calendarNames){
		NSArray *calendars;
		NSMutableArray *calendarIds = [[NSMutableArray alloc]init];
		for(unsigned int i = 0; i < calendarNames.getSize(); ++i){
			CUTF16String calendar;
			calendarNames.copyUTF16StringAtIndex(&calendar, i);
			NSString *calendarId = [[NSString alloc]initWithCharacters:(const unichar *)calendar.c_str() length:calendar.length()];
			[calendarIds addObject:calendarId];
			[calendarId release];
		}
		C_LONGINT returnValueInternal;
		calendars = getCalendars(calendarStore, calendarIds, returnValueInternal);
		[calendarIds release];
		return calendars;
	}

	CalCalendar *getCalendar(CalCalendarStore *calendarStore, NSString *calendarName, C_LONGINT &returnValue){
		NSArray * calendars = getCalendars(calendarStore, [NSArray arrayWithObject:calendarName], returnValue);
		
		if([calendars count]){
			return [calendars objectAtIndex:0];
		}else{
			return nil;
		}
	}
	
	CalCalendarStore *getCalendarStore(C_LONGINT &returnValue){
		CalCalendarStore *calendarStore = nil;
		
		calendarStore = [CalCalendarStore defaultCalendarStore];
		
		if(!calendarStore)
		{
			returnValue.setIntValue(ERROR_ACCESS_DENIED);
		}
		
		return calendarStore;
	}
	
	void setEventProperty(CalEvent *event, NSString *key, NSString *value){
		NSArray *eventProperties = [NSArray arrayWithObjects:
																@"isAllDay", @"isDetached",
																@"location", @"occurrence",
																@"recurrence" ,@"startDate",
																@"calendar", @"hasAlarm",
																@"nextAlarmDate", @"dateStamp",
																@"notes", @"title",
																@"url", @"endDate", nil];
		if(event){
			NSUInteger pid = [eventProperties indexOfObject:key];
			switch (pid){
				case 0://isAllDay
					event.isAllDay = [value boolValue];
					break;
				case 1://isDetached (readonly)
					break;
				case 2://location
					event.location = value;
					break;
				case 3://occurrence (readonly)
					break;
				case 4://recurrence (dedicated command)
					break;
				case 5://startDate
					if([NSDate dateWithString:value]){
						event.startDate = [NSDate dateWithString:value];
					}
					break;
				case 6://calendar
				{
					C_LONGINT returnValue;
					CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
					if(defaultCalendarStore){
						CalCalendar *calendar = getCalendar(defaultCalendarStore, value, returnValue);
						if(calendar){
							event.calendar = calendar;
						}
					}
				}
					break;
				case 7://hasAlarm (readonly)
					break;
				case 8://nextAlarmDate (readonly)
					break;
				case 9://dateStamp (readonly)
					break;
				case 10://notes
					event.notes = value;
					break;
				case 11://title
					event.title = value;
					break;
				case 12://url
				{
					NSURL *url = [NSURL URLWithString:value];
					if(url){
						event.url = url;
					}
				}
					break;
				case 13://endDate
					if([NSDate dateWithString:value]){
						event.endDate = [NSDate dateWithString:value];
					}
					break;
				default:
					break;
			}
			
		}
	}

	NSDate *getDate(NSString *recordTime, C_LONGINT &returnValue){
		NSDate *date = nil;
		
		date = [NSDate dateWithString:recordTime];
		
		if(!date)
		{
			returnValue.setIntValue(ERROR_INVALID_DATE);
		}
		
		return date;
	}
	
	void getEventProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			
				CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:[NSDate dateWithString:recordSpecifier.date]];
				NSArray *eventProperties = [NSArray arrayWithObjects:
																		@"isAllDay", @"isDetached",
																		@"location", @"occurrence",
																		@"recurrence" ,@"startDate",
																		@"calendar", @"hasAlarm",
																		@"nextAlarmDate", @"dateStamp",
																		@"notes", @"title",
																		@"url", @"endDate",
																		@"attendees", nil];
				if(event){
					NSUInteger pid = [eventProperties indexOfObject:recordSpecifier.key];
					NSString *attendees = nil;
					switch (pid){
						case 0://isAllDay
							if(event.isAllDay)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 1://isDetached
							if(event.isDetached)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 2://location
							recordSpecifier.value.setUTF16String(event.location);
							recordSpecifier.isOK = true;
							break;
						case 3://occurrence
							recordSpecifier.value.setUTF16String([event.occurrence description]);
							recordSpecifier.isOK = true;
							break;
						case 4://recurrence
                        {
                            CalRecurrenceRule *recurrenceRule = event.recurrenceRule;
                            @autoreleasepool
                            {
                                NSNumber *recurrenceInterval = [NSNumber numberWithInt:0];
                                NSString *firstDayOfTheWeek = @"";
                                NSString *recurrenceType = @"";
                                NSArray *daysOfTheWeek = @[];
                                NSArray *daysOfTheMonth = @[];
                                NSArray *nthWeekDaysOfTheMonth = @[];
                                NSArray *monthsOfTheYear = @[];
                                NSDictionary *recurrenceEnd = @{};
                                
                                if(recurrenceRule)
                                {
                                    recurrenceInterval = [NSNumber numberWithInt:recurrenceRule.recurrenceInterval];
                                    firstDayOfTheWeek = [@[@"",
                                                           @"Sunday",
                                                           @"Monday",
                                                           @"Tuesday",
                                                           @"Wednesday",
                                                           @"Thursday",
                                                           @"Friday",
                                                           @"Saturday"] objectAtIndex:recurrenceRule.firstDayOfTheWeek];
                                    recurrenceType = [@[@"Daily",
                                                        @"Weekly",
                                                        @"Monthly",
                                                        @"Yearly"] objectAtIndex:recurrenceRule.recurrenceType];
                                    daysOfTheWeek = recurrenceRule.daysOfTheWeek ? recurrenceRule.daysOfTheWeek : @[];
                                    daysOfTheMonth = recurrenceRule.daysOfTheMonth ? recurrenceRule.daysOfTheMonth : @[];
                                    nthWeekDaysOfTheMonth = recurrenceRule.nthWeekDaysOfTheMonth ? recurrenceRule.nthWeekDaysOfTheMonth : @[];
                                    monthsOfTheYear = recurrenceRule.monthsOfTheYear ? recurrenceRule.monthsOfTheYear : @[];
                                    
                                    #define DATE_FORMAT_ISO_GMT @"yyyy-MM-dd'T'HH:mm:ss'Z'"
                                    NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
                                    [GMT setDateFormat:DATE_FORMAT_ISO_GMT];
                                    [GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];

                                    recurrenceEnd = recurrenceRule.recurrenceEnd ? @{
                                                                                     @"occurrenceCount":[NSNumber numberWithInt:recurrenceRule.recurrenceEnd.occurrenceCount],
                                                                                     @"endDate":recurrenceRule.recurrenceEnd.endDate ? [GMT stringFromDate:recurrenceRule.recurrenceEnd.endDate] : @""
                                                                                     } : @{};
                                     [GMT release];
                                }
                                
                                NSDictionary *recurrence = @{
                                                             @"recurrenceInterval":recurrenceInterval,
                                                             @"firstDayOfTheWeek":firstDayOfTheWeek,
                                                             @"recurrenceType":recurrenceType,
                                                             @"recurrenceEnd":recurrenceEnd,
                                                             @"daysOfTheWeek":daysOfTheWeek,
                                                             @"daysOfTheMonth":daysOfTheMonth,
                                                             @"nthWeekDaysOfTheMonth":nthWeekDaysOfTheMonth,
                                                             @"monthsOfTheYear":monthsOfTheYear
                                                             };
                                if([NSJSONSerialization isValidJSONObject:recurrence])
                                {
                                    NSData *jsonData = [NSJSONSerialization
                                                        dataWithJSONObject:recurrence
                                                        options:0
                                                        error:NULL];
                                    if(jsonData)
                                    {
                                        NSString *json = [NSString stringWithCString:(const char *)[jsonData bytes] encoding:NSUTF8StringEncoding];
                                        recordSpecifier.value.setUTF16String(json);
                                        recordSpecifier.isOK = true;
                                    }
                                }
                            }
                        }
							break;
						case 5://startDate
							recordSpecifier.value.setUTF16String([event.startDate description]);
							recordSpecifier.isOK = true;
							break;
						case 6://calendar
							recordSpecifier.value.setUTF16String([event.calendar uid]);
							recordSpecifier.isOK = true;
							break;
						case 7://hasAlarm
							if(event.hasAlarm)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 8://nextAlarmDate
							recordSpecifier.value.setUTF16String([event.nextAlarmDate description]);
							recordSpecifier.isOK = true;
							break;
						case 9://dateStamp
							recordSpecifier.value.setUTF16String([event.dateStamp description]);
							recordSpecifier.isOK = true;
							break;
						case 10://notes
							recordSpecifier.value.setUTF16String(event.notes);
							recordSpecifier.isOK = true;
							break;
						case 11://title
							recordSpecifier.value.setUTF16String(event.title);
							recordSpecifier.isOK = true;
							break;
						case 12://url
							recordSpecifier.value.setUTF16String([event.url absoluteString]);
							recordSpecifier.isOK = true;
							break;
						case 13://endDate
							recordSpecifier.value.setUTF16String([event.endDate description]);
							recordSpecifier.isOK = true;
							break;
						case 14://attendees
							attendees = copyAttendeesDictionary(event.attendees);
							recordSpecifier.value.setUTF16String(attendees);
							[attendees release];
							recordSpecifier.isOK = true;
						default:
							break;
					}		
				}
				recordSpecifier.isDone = true;
		}
	}
	
	int newProcess(void* procPtr, int stackSize, NSString *name){
		C_TEXT t;
		t.setUTF16String(name);
		
		return PA_NewProcess(procPtr, stackSize, (PA_Unichar *)t.getUTF16StringPtr());
	}
	
	NSColor *getColorFromString(NSString *dictionary){
		NSColor *color = NULL;
		if(dictionary)
		{
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, (CFDataRef)[dictionary dataUsingEncoding:NSUTF8StringEncoding], kCFPropertyListImmutable, NULL);
			
			if(dictionaryPropertyList)
			{
				if(CFGetTypeID(dictionaryPropertyList) == CFDictionaryGetTypeID())
				{
					NSDictionary *dictionary = (NSDictionary *)dictionaryPropertyList;
					
					float redComponent = [[dictionary objectForKey:@"redComponent"]floatValue];
					float greenComponent = [[dictionary objectForKey:@"greenComponent"]floatValue];
					float blueComponent = [[dictionary objectForKey:@"blueComponent"]floatValue];
					float alphaComponent = [[dictionary objectForKey:@"alphaComponent"]floatValue];
					
					color = [NSColor colorWithDeviceRed:redComponent green:greenComponent blue:blueComponent alpha:alphaComponent];
				}
				CFRelease(dictionaryPropertyList);
			}
		}
		
		return color;
		
	}
	
	void getDateTimeOffsetFromString(NSString *dateString, PA_Date *date, int *time, int *offset){
		if(dateString)
		{
			NSDate *nsd = [NSDate dateWithString:dateString];
			if(nsd)
			{
				NSString *description = [nsd description];
				
				if([description length] == 25)
				{
					date->fYear = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
					date->fMonth = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
					date->fDay = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
					int hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
					int minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
					int second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
					*time = second + (minute * 60) + (hour * 3600);
					NSTimeZone *zone = [NSTimeZone timeZoneWithName:[@"GMT" stringByAppendingString:[dateString substringWithRange:NSMakeRange(20,5)]]];
					if(zone) *offset = [zone secondsFromGMTForDate:nsd];
				}
			}
		}	
	}
	
	NSString *copyDateTimeZoneString(PA_Date *date, int time, NSString *name){
		NSString *description = NULL;
		
		if(name)
		{
			NSTimeZone *zone = [NSTimeZone timeZoneWithName:name];
			if(!zone) zone = [NSTimeZone localTimeZone];
			
			CFGregorianDate gregDate;
			gregDate.year = date->fYear;
			gregDate.month = date->fMonth;
			gregDate.day = date->fDay;
			gregDate.hour = 0;
			gregDate.minute = 0;
			gregDate.second = 0;
			
			CFGregorianUnits offset;
			offset.years = 0;
			offset.months = 0;
			offset.days = 0;
			offset.minutes = 0;
			offset.hours = 0;
			offset.seconds = time;
			
			if( CFGregorianDateIsValid( gregDate, kCFGregorianUnitsYears+kCFGregorianUnitsMonths+kCFGregorianUnitsDays))
			{
				CFAbsoluteTime at = CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)zone);
				CFAbsoluteTime seconds = CFAbsoluteTimeAddGregorianUnits(at, (CFTimeZoneRef)zone, offset);
				NSDate *nsd = (NSDate *)CFDateCreate(kCFAllocatorDefault, seconds);
				description = [[NSString alloc]initWithString:[nsd description]];
				[nsd release];
			}
			
		}
		
		if(description)
		{
			return description;
		}else{
			return @"";	
		}
		
	}
	
	NSString *copyColorString(NSColor *color){
		NSString *colorData = NULL;
		
		if(color)
		{
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			
			[dictionary setObject:[NSNumber numberWithFloat:[color redComponent]] forKey:@"redComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color greenComponent]] forKey:@"greenComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color blueComponent]] forKey:@"blueComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color alphaComponent]] forKey:@"alphaComponent"];
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			colorData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			[dictionary release];
		}else{colorData = @"";}
		
		return colorData;
		
	}
	
	NSColor *getColorIndex(int index){
		float redComponent;
		float greenComponent;
		float blueComponent;
		float alphaComponent = 1;
		
		switch(index){
			case 1 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 2 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 3 :
				redComponent = 0;
				greenComponent = 0.4;
				blueComponent = 1;
				break;
			case 4 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.9333333333333333481;
				break;
			case 5 :
				redComponent = 0.6;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 6 :
				redComponent = 0.6;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 7 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 8 :
				redComponent = 1;
				greenComponent = 0.6;
				blueComponent = 0;
				break;
			case 9 :
				redComponent = 0;
				greenComponent = 0.7333333333333332815;
				blueComponent = 0;
				break;
			case 10 :
				redComponent = 0;
				greenComponent = 0.6;
				blueComponent = 0;
				break;
			case 11 :
				redComponent = 0;
				greenComponent = 0.2;
				blueComponent = 0.4;
				break;
			case 12 :
				redComponent = 0.266666666666666663;
				greenComponent = 0.266666666666666663;
				blueComponent = 0.266666666666666663;
				break;
			case 13 :
				redComponent = 0.8666666666666666963;
				greenComponent = 0.8666666666666666963;
				blueComponent = 0.8666666666666666963;
				break;
			case 14 :
				redComponent = 0;
				greenComponent = 0.4;
				blueComponent = 0.6;
				break;
			case 15 :
				redComponent = 0.6666666666666666297;
				greenComponent = 0.6666666666666666297;
				blueComponent = 0.6666666666666666297;
				break;
			case 16 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 17 :
				redComponent = 0.3686274509804;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 18 :
				redComponent = 0.3372549019607843368;
				greenComponent = 0.01568627450980392135;
				blueComponent = 1;
				break;
			case 19 :
				redComponent = 0.2823529411764705843;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 20 :
				redComponent = 0.2941176470588235392;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 21 :
				redComponent = 0.1960784313725490169;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 22 :
				redComponent = 0.152941176470588247;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 23 :
				redComponent = 0.1098039215686274495;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 24 :
				redComponent = 0.06666666666666666574;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 25 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 26 :
				redComponent = 0;
				greenComponent = 0.01568627450980392135;
				blueComponent = 1;
				break;
			case 27 :
				redComponent = 0;
				greenComponent = 0.05882352941176470507;
				blueComponent = 1;
				break;
			case 28 :
				redComponent = 0;
				greenComponent = 0.1019607843137254888;
				blueComponent = 1;
				break;
			case 29 :
				redComponent = 0;
				greenComponent = 0.1450980392156862864;
				blueComponent = 1;
				break;
			case 30 :
				redComponent = 0;
				greenComponent = 0.1882352941176470562;
				blueComponent = 1;
				break;
			case 31 :
				redComponent = 0;
				greenComponent = 0.2313725490196;
				blueComponent = 1;
				break;
			case 32 :
				redComponent = 0;
				greenComponent = 0.2745098039215686514;
				blueComponent = 1;
				break;
			case 33 :
				redComponent = 0;
				greenComponent = 0.3019607843137254721;
				blueComponent = 1;
				break;
			case 34 :
				redComponent = 0;
				greenComponent = 0.3294117647058823484;
				blueComponent = 1;
				break;
			case 35 :
				redComponent = 0;
				greenComponent = 0.3568627450980392246;
				blueComponent = 1;
				break;
			case 36 :
				redComponent = 0;
				greenComponent = 0.3843137254902;
				blueComponent = 1;
				break;
			case 37 :
				redComponent = 0;
				greenComponent = 0.4117647058823529216;
				blueComponent = 1;
				break;
			case 38 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.4470588235294117863;
				blueComponent = 1;
				break;
			case 39 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.4862745098039215619;
				blueComponent = 1;
				break;
			case 40 :
				redComponent = 0.007843137254902;
				greenComponent = 0.5098039215686274161;
				blueComponent = 1;
				break;
			case 41 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0.5411764705882352589;
				blueComponent = 1;
				break;
			case 42 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.5725490196078431016;
				blueComponent = 1;
				break;
			case 43 :
				redComponent = 0.007843137254902;
				greenComponent = 0.6;
				blueComponent = 1;
				break;
			case 44 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 45 :
				redComponent = 0;
				greenComponent = 0.6235294117647;
				blueComponent = 1;
				break;
			case 46 :
				redComponent = 0.0627450980392156854;
				greenComponent = 0.6823529411764706065;
				blueComponent = 1;
				break;
			case 47 :
				redComponent = 0.02745098039215686236;
				greenComponent = 0.6941176470588235059;
				blueComponent = 1;
				break;
			case 48 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.7215686274509803821;
				blueComponent = 1;
				break;
			case 49 :
				redComponent = 0;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 50 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.7803921568627451011;
				blueComponent = 1;
				break;
			case 51 :
				redComponent = 0;
				greenComponent = 0.8078431372549;
				blueComponent = 1;
				break;
			case 52 :
				redComponent = 0;
				greenComponent = 0.8431372549019607865;
				blueComponent = 1;
				break;
			case 53 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.8745098039215686292;
				blueComponent = 1;
				break;
			case 54 :
				redComponent = 0.01960784313725490169;
				greenComponent = 0.9019607843137255054;
				blueComponent = 1;
				break;
			case 55 :
				redComponent = 0.03921568627451;
				greenComponent = 0.9372549019607843146;
				blueComponent = 1;
				break;
			case 56 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.9647058823529411908;
				blueComponent = 1;
				break;
			case 57 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0.9921568627451;
				blueComponent = 1;
				break;
			case 58 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9764705882353;
				break;
			case 59 :
				redComponent = 0.01568627450980392135;
				greenComponent = 1;
				blueComponent = 0.949019607843137214;
				break;
			case 60 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9215686274509803377;
				break;
			case 61 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.8862745098039215286;
				break;
			case 62 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.8274509803921568096;
				break;
			case 63 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.7921568627451;
				break;
			case 64 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.7647058823529411242;
				break;
			case 65 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.737254901960784359;
				break;
			case 66 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.6509803921568627638;
				break;
			case 67 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.5647058823529411686;
				break;
			case 68 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.478431372549019629;
				break;
			case 69 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.3921568627451;
				break;
			case 70 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.3098039215686274606;
				break;
			case 71 :
				redComponent = 0.01176470588235294101;
				greenComponent = 1;
				blueComponent = 0.2352941176470588203;
				break;
			case 72 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.04705882352941176405;
				break;
			case 73 :
				redComponent = 0.04705882352941176405;
				greenComponent = 1;
				blueComponent = 0.01176470588235294101;
				break;
			case 74 :
				redComponent = 0.1372549019607843257;
				greenComponent = 1;
				blueComponent = 0.01568627450980392135;
				break;
			case 75 :
				redComponent = 0.2078431372549;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 76 :
				redComponent = 0.2941176470588235392;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 77 :
				redComponent = 0.3764705882353;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 78 :
				redComponent = 0.4627450980392157076;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 79 :
				redComponent = 0.5490196078431373028;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 80 :
				redComponent = 0.6549019607843137303;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 81 :
				redComponent = 0.6549019607843137303;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 82 :
				redComponent = 0.6941176470588235059;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 83 :
				redComponent = 0.7333333333333332815;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 84 :
				redComponent = 0.7725490196078431682;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 85 :
				redComponent = 0.8156862745098;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 86 :
				redComponent = 0.8549019607843136859;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 87 :
				redComponent = 0.8941176470588235725;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 88 :
				redComponent = 0.9333333333333333481;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 89 :
				redComponent = 0.9725490196078431238;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 90 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0;
				break;
			case 91 :
				redComponent = 1;
				greenComponent = 0.9529411764705881804;
				blueComponent = 0;
				break;
			case 92 :
				redComponent = 1;
				greenComponent = 0.9137254901960784048;
				blueComponent = 0;
				break;
			case 93 :
				redComponent = 1;
				greenComponent = 0.8784313725490195957;
				blueComponent = 0;
				break;
			case 94 :
				redComponent = 1;
				greenComponent = 0.8352941176470588536;
				blueComponent = 0;
				break;
			case 95 :
				redComponent = 1;
				greenComponent = 0.7960784313725489669;
				blueComponent = 0;
				break;
			case 96 :
				redComponent = 1;
				greenComponent = 0.7568627450980391913;
				blueComponent = 0;
				break;
			case 97 :
				redComponent = 1;
				greenComponent = 0.7058823529411765163;
				blueComponent = 0;
				break;
			case 98 :
				redComponent = 1;
				greenComponent = 0.6313725490196;
				blueComponent = 0;
				break;
			case 99 :
				redComponent = 1;
				greenComponent = 0.5568627450980392357;
				blueComponent = 0;
				break;
			case 100 :
				redComponent = 1;
				greenComponent = 0.4862745098039215619;
				blueComponent = 0;
				break;
			case 101 :
				redComponent = 1;
				greenComponent = 0.4117647058823529216;
				blueComponent = 0;
				break;
			case 102 :
				redComponent = 1;
				greenComponent = 0.3372549019607843368;
				blueComponent = 0;
				break;
			case 103 :
				redComponent = 1;
				greenComponent = 0.2627450980392156965;
				blueComponent = 0;
				break;
			case 104 :
				redComponent = 1;
				greenComponent = 0.1568627450980392135;
				blueComponent = 0.003921568627451;
				break;
			case 105 :
				redComponent = 1;
				greenComponent = 0.1176470588235294101;
				blueComponent = 0;
				break;
			case 106 :
				redComponent = 1;
				greenComponent = 0.04313725490196;
				blueComponent = 0;
				break;
			case 107 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.02745098039215686236;
				break;
			case 108 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.09803921568627450844;
				break;
			case 109 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.1725490196078431349;
				break;
			case 110 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.2470588235294117752;
				break;
			case 111 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.3215686274509804154;
				break;
			case 112 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.3960784313725490002;
				break;
			case 113 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.4705882352941176405;
				break;
			case 114 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.5450980392156862253;
				break;
			case 115 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.6196078431372549211;
				break;
			case 116 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.6941176470588235059;
				break;
			case 117 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.7686274509804;
				break;
			case 118 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.8431372549019607865;
				break;
			case 119 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.9176470588235293713;
				break;
			case 120 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.9921568627451;
				break;
			case 121 :
				redComponent = 0.9372549019607843146;
				greenComponent = 0.01176470588235294101;
				blueComponent = 1;
				break;
			case 122 :
				redComponent = 0.8627450980392157298;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 123 :
				redComponent = 0.788235294117647034;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 124 :
				redComponent = 0.7137254901960784492;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 125 :
				redComponent = 0.6392156862745;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 126 :
				redComponent = 0.5647058823529411686;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 127 :
				redComponent = 0.4901960784313725283;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 128 :
				redComponent = 0.4156862745098;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 129 :
				redComponent = 0.8784313725490195957;
				greenComponent = 0.8784313725490195957;
				blueComponent = 1;
				break;
			case 130 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 131 :
				redComponent = 0.627450980392156854;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 132 :
				redComponent = 0.4980392156862745168;
				greenComponent = 0.4980392156862745168;
				blueComponent = 1;
				break;
			case 133 :
				redComponent = 0.372549019607843146;
				greenComponent = 0.372549019607843146;
				blueComponent = 1;
				break;
			case 134 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.2509803921568627416;
				blueComponent = 1;
				break;
			case 135 :
				redComponent = 0.1254901960784313708;
				greenComponent = 0.1254901960784313708;
				blueComponent = 1;
				break;
			case 136 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 137 :
				redComponent = 0;
				greenComponent = 0.05882352941176470507;
				blueComponent = 0.9254901960784314152;
				break;
			case 138 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.847058823529411753;
				break;
			case 139 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.8117647058823529438;
				break;
			case 140 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.6901960784313725394;
				break;
			case 141 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.6117647058823529882;
				break;
			case 142 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.5333333333333333259;
				break;
			case 143 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.4549019607843137192;
				break;
			case 144 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.3764705882353;
				break;
			case 145 :
				redComponent = 0.8745098039215686292;
				greenComponent = 0.9411764705882352811;
				blueComponent = 1;
				break;
			case 146 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.8784313725490195957;
				blueComponent = 1;
				break;
			case 147 :
				redComponent = 0.627450980392156854;
				greenComponent = 0.8117647058823529438;
				blueComponent = 1;
				break;
			case 148 :
				redComponent = 0.4980392156862745168;
				greenComponent = 0.7450980392156862919;
				blueComponent = 1;
				break;
			case 149 :
				redComponent = 0.372549019607843146;
				greenComponent = 0.6901960784313725394;
				blueComponent = 1;
				break;
			case 150 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.6313725490196;
				blueComponent = 1;
				break;
			case 151 :
				redComponent = 0.1254901960784313708;
				greenComponent = 0.5686274509804;
				blueComponent = 1;
				break;
			case 152 :
				redComponent = 0;
				greenComponent = 0.5058823529411764497;
				blueComponent = 1;
				break;
			case 153 :
				redComponent = 0;
				greenComponent = 0.4666666666666666741;
				blueComponent = 0.9254901960784314152;
				break;
			case 154 :
				redComponent = 0;
				greenComponent = 0.4274509803921568429;
				blueComponent = 0.847058823529411753;
				break;
			case 155 :
				redComponent = 0;
				greenComponent = 0.3882352941176470673;
				blueComponent = 0.7686274509804;
				break;
			case 156 :
				redComponent = 0;
				greenComponent = 0.3490196078431372362;
				blueComponent = 0.6901960784313725394;
				break;
			case 157 :
				redComponent = 0;
				greenComponent = 0.3215686274509804154;
				blueComponent = 0.6117647058823529882;
				break;
			case 158 :
				redComponent = 0;
				greenComponent = 0.2705882352941176294;
				blueComponent = 0.5333333333333333259;
				break;
			case 159 :
				redComponent = 0;
				greenComponent = 0.2313725490196;
				blueComponent = 0.4549019607843137192;
				break;
			case 160 :
				redComponent = 0;
				greenComponent = 0.1882352941176470562;
				blueComponent = 0.3764705882353;
				break;
			case 161 :
				redComponent = 0.8745098039215686292;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 162 :
				redComponent = 0.7529411764705882248;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 163 :
				redComponent = 0.627450980392156854;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 164 :
				redComponent = 0.4980392156862745168;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 165 :
				redComponent = 0.372549019607843146;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 166 :
				redComponent = 0.2509803921568627416;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 167 :
				redComponent = 0.1254901960784313708;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 168 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 169 :
				redComponent = 0;
				greenComponent = 0.9254901960784314152;
				blueComponent = 0.9176470588235293713;
				break;
			case 170 :
				redComponent = 0;
				greenComponent = 0.8431372549019607865;
				blueComponent = 0.8392156862745;
				break;
			case 171 :
				redComponent = 0;
				greenComponent = 0.7647058823529411242;
				blueComponent = 0.7607843137255;
				break;
			case 172 :
				redComponent = 0;
				greenComponent = 0.686274509803921573;
				blueComponent = 0.6823529411764706065;
				break;
			case 173 :
				redComponent = 0;
				greenComponent = 0.6235294117647;
				blueComponent = 0.6196078431372549211;
				break;
			case 174 :
				redComponent = 0;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.5294117647058823595;
				break;
			case 175 :
				redComponent = 0;
				greenComponent = 0.4549019607843137192;
				blueComponent = 0.4509803921568627527;
				break;
			case 176 :
				redComponent = 0;
				greenComponent = 0.3764705882353;
				blueComponent = 0.372549019607843146;
				break;
			case 177 :
				redComponent = 0.8745098039215686292;
				greenComponent = 1;
				blueComponent = 0.8862745098039215286;
				break;
			case 178 :
				redComponent = 0.7529411764705882248;
				greenComponent = 1;
				blueComponent = 0.7725490196078431682;
				break;
			case 179 :
				redComponent = 0.627450980392156854;
				greenComponent = 1;
				blueComponent = 0.6549019607843137303;
				break;
			case 180 :
				redComponent = 0.4980392156862745168;
				greenComponent = 1;
				blueComponent = 0.5372549019607842924;
				break;
			case 181 :
				redComponent = 0.372549019607843146;
				greenComponent = 1;
				blueComponent = 0.4235294117647;
				break;
			case 182 :
				redComponent = 0.2509803921568627416;
				greenComponent = 1;
				blueComponent = 0.3098039215686274606;
				break;
			case 183 :
				redComponent = 0.1254901960784313708;
				greenComponent = 1;
				blueComponent = 0.1921568627451;
				break;
			case 184 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.07450980392156862642;
				break;
			case 185 :
				redComponent = 0;
				greenComponent = 0.9254901960784314152;
				blueComponent = 0.07058823529411764608;
				break;
			case 186 :
				redComponent = 0;
				greenComponent = 0.847058823529411753;
				blueComponent = 0.0627450980392156854;
				break;
			case 187 :
				redComponent = 0;
				greenComponent = 0.7686274509804;
				blueComponent = 0.05882352941176470507;
				break;
			case 188 :
				redComponent = 0;
				greenComponent = 0.6901960784313725394;
				blueComponent = 0.05098039215686274439;
				break;
			case 189 :
				redComponent = 0;
				greenComponent = 0.6117647058823529882;
				blueComponent = 0.04705882352941176405;
				break;
			case 190 :
				redComponent = 0;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.03921568627451;
				break;
			case 191 :
				redComponent = 0;
				greenComponent = 0.4549019607843137192;
				blueComponent = 0.03529411764705882304;
				break;
			case 192 :
				redComponent = 0;
				greenComponent = 0.3764705882353;
				blueComponent = 0.02745098039215686236;
				break;
			case 193 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.8745098039215686292;
				break;
			case 194 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.7529411764705882248;
				break;
			case 195 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.627450980392156854;
				break;
			case 196 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.4980392156862745168;
				break;
			case 197 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.372549019607843146;
				break;
			case 198 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.2509803921568627416;
				break;
			case 199 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0.1254901960784313708;
				break;
			case 200 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0;
				break;
			case 201 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0.9137254901960784048;
				blueComponent = 0;
				break;
			case 202 :
				redComponent = 0.847058823529411753;
				greenComponent = 0.8392156862745;
				blueComponent = 0;
				break;
			case 203 :
				redComponent = 0.7686274509804;
				greenComponent = 0.7607843137255;
				blueComponent = 0;
				break;
			case 204 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0.6823529411764706065;
				blueComponent = 0;
				break;
			case 205 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0.6078431372549;
				blueComponent = 0;
				break;
			case 206 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.5294117647058823595;
				blueComponent = 0;
				break;
			case 207 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0.4509803921568627527;
				blueComponent = 0;
				break;
			case 208 :
				redComponent = 0.3764705882353;
				greenComponent = 0.372549019607843146;
				blueComponent = 0;
				break;
			case 209 :
				redComponent = 1;
				greenComponent = 0.8941176470588235725;
				blueComponent = 0.8745098039215686292;
				break;
			case 210 :
				redComponent = 1;
				greenComponent = 0.7921568627451;
				blueComponent = 0.7529411764705882248;
				break;
			case 211 :
				redComponent = 1;
				greenComponent = 0.686274509803921573;
				blueComponent = 0.627450980392156854;
				break;
			case 212 :
				redComponent = 1;
				greenComponent = 0.5764705882353;
				blueComponent = 0.4980392156862745168;
				break;
			case 213 :
				redComponent = 1;
				greenComponent = 0.4705882352941176405;
				blueComponent = 0.372549019607843146;
				break;
			case 214 :
				redComponent = 1;
				greenComponent = 0.3686274509804;
				blueComponent = 0.2509803921568627416;
				break;
			case 215 :
				redComponent = 1;
				greenComponent = 0.25882352941176473;
				blueComponent = 0.1254901960784313708;
				break;
			case 216 :
				redComponent = 1;
				greenComponent = 0.152941176470588247;
				blueComponent = 0;
				break;
			case 217 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0.1411764705882352922;
				blueComponent = 0;
				break;
			case 218 :
				redComponent = 0.847058823529411753;
				greenComponent = 0.129411764705882365;
				blueComponent = 0;
				break;
			case 219 :
				redComponent = 0.8117647058823529438;
				greenComponent = 0.1254901960784313708;
				blueComponent = 0;
				break;
			case 220 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0.1058823529411764691;
				blueComponent = 0;
				break;
			case 221 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0.09411764705882352811;
				blueComponent = 0;
				break;
			case 222 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.08235294117647;
				blueComponent = 0;
				break;
			case 223 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0.07058823529411764608;
				blueComponent = 0;
				break;
			case 224 :
				redComponent = 0.3764705882353;
				greenComponent = 0.05490196078431372473;
				blueComponent = 0;
				break;
			case 225 :
				redComponent = 1;
				greenComponent = 0.8745098039215686292;
				blueComponent = 1;
				break;
			case 226 :
				redComponent = 1;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 227 :
				redComponent = 1;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 228 :
				redComponent = 1;
				greenComponent = 0.4980392156862745168;
				blueComponent = 1;
				break;
			case 229 :
				redComponent = 1;
				greenComponent = 0.372549019607843146;
				blueComponent = 1;
				break;
			case 230 :
				redComponent = 1;
				greenComponent = 0.2509803921568627416;
				blueComponent = 1;
				break;
			case 231 :
				redComponent = 1;
				greenComponent = 0.1254901960784313708;
				blueComponent = 1;
				break;
			case 232 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 233 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0;
				blueComponent = 0.9215686274509803377;
				break;
			case 234 :
				redComponent = 0.847058823529411753;
				greenComponent = 0;
				blueComponent = 0.8431372549019607865;
				break;
			case 235 :
				redComponent = 0.8117647058823529438;
				greenComponent = 0;
				blueComponent = 0.8117647058823529438;
				break;
			case 236 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0;
				blueComponent = 0.6901960784313725394;
				break;
			case 237 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0;
				blueComponent = 0.6117647058823529882;
				break;
			case 238 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0;
				blueComponent = 0.5333333333333333259;
				break;
			case 239 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0;
				blueComponent = 0.4549019607843137192;
				break;
			case 240 :
				redComponent = 0.3764705882353;
				greenComponent = 0;
				blueComponent = 0.3764705882353;
				break;
			case 241 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 242 :
				redComponent = 0.9333333333333333481;
				greenComponent = 0.9333333333333333481;
				blueComponent = 0.9333333333333333481;
				break;
			case 243 :
				redComponent = 0.8666666666666666963;
				greenComponent = 0.8666666666666666963;
				blueComponent = 0.8666666666666666963;
				break;
			case 244 :
				redComponent = 0.8;
				greenComponent = 0.8;
				blueComponent = 0.8;
				break;
			case 245 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.7529411764705882248;
				blueComponent = 0.7529411764705882248;
				break;
			case 246 :
				redComponent = 0.6666666666666666297;
				greenComponent = 0.6666666666666666297;
				blueComponent = 0.6666666666666666297;
				break;
			case 247 :
				redComponent = 0.6;
				greenComponent = 0.6;
				blueComponent = 0.6;
				break;
			case 248 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.5333333333333333259;
				break;
			case 249 :
				redComponent = 0.4666666666666666741;
				greenComponent = 0.4666666666666666741;
				blueComponent = 0.4666666666666666741;
				break;
			case 250 :
				redComponent = 0.4;
				greenComponent = 0.4;
				blueComponent = 0.4;
				break;
			case 251 :
				redComponent = 0.3333333333333333148;
				greenComponent = 0.3333333333333333148;
				blueComponent = 0.3333333333333333148;
				break;
			case 252 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.2509803921568627416;
				blueComponent = 0.2509803921568627416;
				break;
			case 253 :
				redComponent = 0.2;
				greenComponent = 0.2;
				blueComponent = 0.2;
				break;
			case 254 :
				redComponent = 0.1333333333333333315;
				greenComponent = 0.1333333333333333315;
				blueComponent = 0.1333333333333333315;
				break;
			case 255 :
				redComponent = 0.06666666666666666574;
				greenComponent = 0.06666666666666666574;
				blueComponent = 0.06666666666666666574;
				break;
			default :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0;
				break;
		}	
		
		//RGB -> BGR
		return [NSColor colorWithDeviceRed:blueComponent green:greenComponent blue:redComponent alpha:alphaComponent];
	}
	
	CalAlarm *getAlarmFromString(NSString *dictionary){
		CalAlarm *alarm = nil;
		NSDate *d = nil;
		NSURL *u = nil;
		
		if(dictionary){
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, (CFDataRef)[dictionary dataUsingEncoding:NSUTF8StringEncoding], kCFPropertyListImmutable, NULL);
			
			if(dictionaryPropertyList){
				
				if(CFGetTypeID(dictionaryPropertyList) == CFDictionaryGetTypeID()){
					
					alarm = [CalAlarm alarm];
					NSDictionary *dictionary = (NSDictionary *)dictionaryPropertyList;
					
					if([dictionary objectForKey:@"action"])
						alarm.action = (NSString *)[dictionary objectForKey:@"action"];
					
					if([dictionary objectForKey:@"absoluteTrigger"]){
						d = [NSDate dateWithString:(NSString *)[dictionary objectForKey:@"absoluteTrigger"]];
						if(d)alarm.absoluteTrigger = d;
					}
					
					if([dictionary objectForKey:@"emailAddress"])
						alarm.emailAddress = (NSString *)[dictionary objectForKey:@"emailAddress"];
					
					if([dictionary objectForKey:@"relativeTrigger"])
						alarm.relativeTrigger = [[dictionary objectForKey:@"relativeTrigger"]doubleValue];
					
					if([dictionary objectForKey:@"sound"])
						alarm.sound = (NSString *)[dictionary objectForKey:@"sound"];
					
					if([dictionary objectForKey:@"url"]){
						u = [NSURL URLWithString:(NSString *)[dictionary objectForKey:@"url"]];
						if(u)if([u isFileURL])alarm.url = u;
					}
				}
				CFRelease(dictionaryPropertyList);
			}
		}
		
		return alarm;
		
	}
	
	NSString *copyAlarmString(CalAlarm *alarm){
		NSString *alarmData = nil;
		
		if(alarm)
		{
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			
			if(alarm.action)
			{
				[dictionary setObject:alarm.action forKey:@"action"];
			}else{
				[dictionary setObject:@"" forKey:@"action"];
			}
			if(alarm.absoluteTrigger)
			{
				[dictionary setObject:[alarm.absoluteTrigger description] forKey:@"absoluteTrigger"];
			}else{
				[dictionary setObject:@"" forKey:@"absoluteTrigger"];
			}
			if(alarm.emailAddress)
			{
				[dictionary setObject:alarm.emailAddress forKey:@"emailAddress"];
			}else{
				[dictionary setObject:@"" forKey:@"emailAddress"];
			}
			if(alarm.relativeTrigger)
			{
				[dictionary setObject:[NSNumber numberWithDouble:alarm.relativeTrigger] forKey:@"relativeTrigger"];
			}else{
				[dictionary setObject:@"" forKey:@"relativeTrigger"];
			}
			if(alarm.sound)
			{
				[dictionary setObject:alarm.sound forKey:@"sound"];
			}else{
				[dictionary setObject:@"" forKey:@"sound"];
			}
			if(alarm.url)
			{
				[dictionary setObject:[alarm.url absoluteString] forKey:@"url"];
			}else{
				[dictionary setObject:@"" forKey:@"url"];
			}
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			alarmData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			[dictionary release];
			
		}else{alarmData = @"";}
		
		return alarmData;	
		
	}
	
	void getCalendarProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalCalendar *calendar = getCalendar(defaultCalendarStore, recordSpecifier.uid, returnValue);
			if(calendar){
				NSArray *calendarProperties = [NSArray arrayWithObjects:
																			 @"color", @"isEditable", @"notes", @"title", @"type", nil];
				
				NSUInteger pid = [calendarProperties indexOfObject:recordSpecifier.key];
				NSString *colorString;
				
				switch (pid){
					case 0://color
						colorString = copyColorString(calendar.color);
						recordSpecifier.value.setUTF16String(colorString);
						[colorString release];
						recordSpecifier.isOK = true;
						break;
					case 1://isEditable
						if(calendar.isEditable)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 2://notes
						recordSpecifier.value.setUTF16String(calendar.notes);
						recordSpecifier.isOK = true;
						break;
					case 3://title
						recordSpecifier.value.setUTF16String(calendar.title);
						recordSpecifier.isOK = true;
						break;
					case 4://type
						recordSpecifier.value.setUTF16String(calendar.type);
						recordSpecifier.isOK = true;
						break;
					default:
						break;
				}
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getTaskProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
			NSArray *taskProperties = [NSArray arrayWithObjects:
																 @"dueDate", @"isCompleted",
																 @"priority", @"completedDate" ,
																 @"hasAlarm", @"nextAlarmDate",
																 @"calendar", @"dateStamp",
																 @"notes", @"title",
																 @"url", nil];
			
			if(task){
				NSUInteger pid = [taskProperties indexOfObject:recordSpecifier.key];
				switch (pid){
					case 0://dueDate
						recordSpecifier.value.setUTF16String([task.dueDate description]);
						recordSpecifier.isOK = true;
						break;
					case 1://isCompleted
						if(task.isCompleted)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 2://priority
						if(task.priority){
							recordSpecifier.value.setUTF16String([[NSNumber numberWithInt:task.priority]stringValue]);
						}else{
							recordSpecifier.value.setUTF16String(@"0");
						}
						recordSpecifier.isOK = true;
						break;
					case 3://completedDate
						recordSpecifier.value.setUTF16String([task.completedDate description]);
						recordSpecifier.isOK = true;
						break;
					case 4://hasAlarm
						if(task.hasAlarm)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 5://nextAlarmDate
						recordSpecifier.value.setUTF16String([task.nextAlarmDate description]);
						recordSpecifier.isOK = true;
						break;
					case 6://calendar
						recordSpecifier.value.setUTF16String([task.calendar uid]);
						recordSpecifier.isOK = true;
						break;
					case 7://dateStamp
						recordSpecifier.value.setUTF16String([task.dateStamp description]);
						recordSpecifier.isOK = true;
						break;
					case 8://notes
						recordSpecifier.value.setUTF16String(task.notes);
						recordSpecifier.isOK = true;
						break;
					case 9://title
						recordSpecifier.value.setUTF16String(task.title);
						recordSpecifier.isOK = true;
						break;
					case 10://url
						recordSpecifier.value.setUTF16String([task.url absoluteString]);
						recordSpecifier.isOK = true;
						break;
						
					default:
						break;
				}
				
			}
			recordSpecifier.isDone = true;
		}
	}
	
	NSString * appleScriptExecuteFunction(NSString *fileName, NSString *functionName, NSString *argument1, NSString *argument2, NSString *argument3){
		NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.4DPlugin.iCal"];
		NSString *returnString = nil;
		
		if(thisBundle){
			NSString *scriptPath = [thisBundle
															pathForResource:fileName
															ofType:@"scpt"
															inDirectory:@"scpt"];
			
			if(scriptPath){
				NSURL *scriptUrl = [[NSURL alloc]initFileURLWithPath:scriptPath];
				if(scriptUrl){
					
					NSDictionary *errInfo;
					NSAppleScript *scriptObject = [[NSAppleScript alloc]initWithContentsOfURL:scriptUrl error:&errInfo];
					BOOL scriptIsCompiled = NO;
					
					if(scriptObject){
						
						scriptIsCompiled = [scriptObject isCompiled];
						
						if(!scriptIsCompiled){
							scriptIsCompiled = [scriptObject compileAndReturnError:&errInfo];
						}
						
						if(scriptIsCompiled){
							
							
							if((!argument1) && (!argument2) && (!argument3)){
								
								NSAppleEventDescriptor *returnValue = [scriptObject executeAndReturnError:&errInfo];
								if(returnValue)
									returnString = [returnValue stringValue];
								
							}else{
								
								NSAppleEventDescriptor *parameters = [NSAppleEventDescriptor listDescriptor];
								
								if(argument1){
									NSAppleEventDescriptor *param1 = [NSAppleEventDescriptor descriptorWithString:argument1];
									[parameters insertDescriptor:param1 atIndex:1];//The list indices are one-based.
									if(argument2){
										NSAppleEventDescriptor *param2 = [NSAppleEventDescriptor descriptorWithString:argument2];
										[parameters insertDescriptor:param2 atIndex:2];//The list indices are one-based.
										if(argument3){
											NSAppleEventDescriptor *param3 = [NSAppleEventDescriptor descriptorWithString:argument3];
											[parameters insertDescriptor:param3 atIndex:3];//The list indices are one-based.
										}
									}
								}
								
								ProcessSerialNumber psn = {0, kCurrentProcess};
								NSAppleEventDescriptor *target =
								[NSAppleEventDescriptor
								 descriptorWithDescriptorType:typeProcessSerialNumber
								 bytes:&psn
								 length:sizeof(ProcessSerialNumber)];
								
								NSAppleEventDescriptor *handler = [NSAppleEventDescriptor descriptorWithString:functionName];//the routine name must be in lower case.
								
								NSAppleEventDescriptor *event =
								[NSAppleEventDescriptor appleEventWithEventClass:kASAppleScriptSuite
																												 eventID:kASSubroutineEvent
																								targetDescriptor:target
																												returnID:kAutoGenerateReturnID
																									 transactionID:kAnyTransactionID];
								
								[event setParamDescriptor:handler forKeyword:keyASSubroutineName];
								[event setParamDescriptor:parameters forKeyword:keyDirectObject];
								
								NSAppleEventDescriptor *returnValue = [scriptObject executeAppleEvent:event error:&errInfo];
								if(returnValue)
									returnString = [returnValue stringValue];
								
							}
							
						}
						
						[scriptObject release];
					}
					[scriptUrl release];
				}
			}
		}
		return returnString;
	}

	void countTaskAlarms(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
		
			if(task){
				recordSpecifier.count = [[task alarms]count];
				recordSpecifier.isOK = true;
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getTaskAlarm(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
			
			if(task){
				int count = [[task alarms]count];
				int index = recordSpecifier.index;
				
				if((count >= index) && (index > 0)){
					CalAlarm *alarm = [[task alarms]objectAtIndex:(NSUInteger)(index - 1)];
					NSString *alarmString = copyAlarmString(alarm);
					recordSpecifier.value.setUTF16String(alarmString);
					[alarmString release];
					recordSpecifier.isOK = true;
				}else{
					NSLog(@"invalid alarm index: %i", index);
				}
				
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getEventAlarm(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:nil];
			if(event){
				int count = [[event alarms]count];
				int index = recordSpecifier.index;
				
				if((count >= index) && (index > 0)){
					CalAlarm *alarm = [[event alarms]objectAtIndex:(NSUInteger)(index - 1)];
					NSString *alarmString = copyAlarmString(alarm);
					recordSpecifier.value.setUTF16String(alarmString);
					[alarmString release];
					recordSpecifier.isOK = true;
				}else{
					NSLog(@"invalid alarm index: %i", index);
				}
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void countEventAlarms(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:nil];
			if(event){
				recordSpecifier.count = [[event alarms]count];
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getAlarmProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalAlarm *alarm = getAlarmFromString(recordSpecifier.uid);
			NSArray *alarmProperties = [NSArray arrayWithObjects:
																	@"action", @"absoluteTrigger",
																	@"emailAddress", @"relativeTrigger",
																	@"sound", @"url", nil];
			if(alarm){
				NSUInteger pid = [alarmProperties indexOfObject:recordSpecifier.key];
				
				switch (pid){
						
					case 0://action
						if(alarm.action){
							recordSpecifier.value.setUTF16String(alarm.action);
							recordSpecifier.isOK = true;
						}
						break;
					case 1://absoluteTrigger
						if(alarm.absoluteTrigger){
							recordSpecifier.value.setUTF16String([alarm.absoluteTrigger description]);
							recordSpecifier.isOK = true;
						}
						break;
					case 2://emailAddress
						if(alarm.emailAddress){
							recordSpecifier.value.setUTF16String(alarm.emailAddress);
							recordSpecifier.isOK = true;
						}
						break;
					case 3://relativeTrigger
						if(alarm.relativeTrigger){
							recordSpecifier.value.setUTF16String([NSString stringWithFormat:@"%f", alarm.relativeTrigger]);
							recordSpecifier.isOK = true;
						}
						break;
					case 4://sound
						if(alarm.sound){
							recordSpecifier.value.setUTF16String(alarm.sound);
							recordSpecifier.isOK = true;
						}
						break;
					case 5://url
						if(alarm.url){
							recordSpecifier.value.setUTF16String([alarm.url absoluteString]);
							recordSpecifier.isOK = true;
						}
						break;
				}
				
			}
			
		}
		recordSpecifier.isDone = true;
		
	}
	
}



#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
		
	}
	catch(...)
	{
		
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			onStartup();
			break;
		case kCloseProcess :
			onCloseProcess();
			break;
// --- Event

		case 1 :
			iCal_Create_event(pResult, pParams);
			break;

		case 2 :
			iCal_Set_event_property(pResult, pParams);
			break;

		case 3 :
			iCal_Get_event_property(pResult, pParams);
			break;

		case 4 :
			iCal_Remove_event(pResult, pParams);
			break;

// --- Task

		case 5 :
			iCal_Create_task(pResult, pParams);
			break;

		case 6 :
			iCal_Set_task_property(pResult, pParams);
			break;

		case 7 :
			iCal_Get_task_property(pResult, pParams);
			break;

		case 8 :
			iCal_Remove_task(pResult, pParams);
			break;

// --- Calendar

		case 9 :
			iCal_Create_calendar(pResult, pParams);
			break;

		case 10 :
			iCal_Set_calendar_property(pResult, pParams);
			break;

		case 11 :
			iCal_Get_calendar_property(pResult, pParams);
			break;

		case 12 :
			iCal_Remove_calendar(pResult, pParams);
			break;

// --- Calendar Store

		case 13 :
			iCal_QUERY_EVENT(pResult, pParams);
			break;

		case 14 :
			iCal_GET_CALENDAR_LIST(pResult, pParams);
			break;

		case 15 :
			iCal_QUERY_TASK(pResult, pParams);
			break;

// --- Type Cast

		case 16 :
			iCal_Make_date(pResult, pParams);
			break;

		case 17 :
			iCal_GET_DATE(pResult, pParams);
			break;

		case 18 :
			iCal_Make_color(pResult, pParams);
			break;

		case 19 :
			iCal_GET_COLOR(pResult, pParams);
			break;

		case 20 :
			iCal_Make_color_from_index(pResult, pParams);
			break;

// --- Recurrence Rule

		case 21 :
			iCal_Remove_event_recurrence(pResult, pParams);
			break;

		case 22 :
			iCal_Set_event_recurrence(pResult, pParams);
			break;

// --- Alarm

		case 23 :
			iCal_Make_alarm(pResult, pParams);
			break;

		case 24 :
			iCal_Get_alarm_property(pResult, pParams);
			break;

		case 25 :
			iCal_Set_alarm_property(pResult, pParams);
			break;

		case 26 :
			iCal_Add_alarm_to_event(pResult, pParams);
			break;

		case 27 :
			iCal_Add_alarm_to_task(pResult, pParams);
			break;

// --- Application

		case 28 :
			iCal_TERMINATE(pResult, pParams);
			break;

		case 29 :
			iCal_LAUNCH(pResult, pParams);
			break;

// --- iCal Direct

		case 30 :
			iCal_SHOW_EVENT(pResult, pParams);
			break;

		case 31 :
			iCal_SHOW_TASK(pResult, pParams);
			break;

		case 32 :
			iCal_SET_VIEW(pResult, pParams);
			break;

		case 33 :
			iCal_SHOW_DATE(pResult, pParams);
			break;

		case 34 :
			iCal_app_Get_task_property(pResult, pParams);
			break;

		case 35 :
			iCal_app_Get_event_property(pResult, pParams);
			break;

// --- Notification

		case 36 :
			iCal_Set_notification_method(pResult, pParams);
			break;

		case 37 :
			iCal_Get_notification_method(pResult, pParams);
			break;

// --- Alarm II

		case 38 :
			iCal_Get_event_alarm(pResult, pParams);
			break;

		case 39 :
			iCal_Count_event_alarms(pResult, pParams);
			break;

		case 40 :
			iCal_Remove_event_alarm(pResult, pParams);
			break;

		case 41 :
			iCal_Set_event_alarm(pResult, pParams);
			break;

		case 42 :
			iCal_Count_task_alarms(pResult, pParams);
			break;

		case 43 :
			iCal_Get_task_alarm(pResult, pParams);
			break;

		case 44 :
			iCal_Remove_task_alarm(pResult, pParams);
			break;

		case 45 :
			iCal_Set_task_alarm(pResult, pParams);
			break;

// --- Timezone

		case 46 :
			iCal_TIMEZONE_LIST(pResult, pParams);
			break;

		case 47 :
			iCal_Get_timezone_info(pResult, pParams);
			break;

		case 48 :
			iCal_Get_timezone_for_offset(pResult, pParams);
			break;

		case 49 :
			iCal_Get_system_timezone(pResult, pParams);
			break;

// --- Event II

		case 50 :
			iCal_Set_event_properties(pResult, pParams);
			break;

	}
}

#pragma mark Event

void iCal_Create_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	ARRAY_TEXT Param4;
	ARRAY_TEXT Param5;
	C_TEXT returnValue;
	C_LONGINT returnValueInternal;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);

	NSError *error = nil;
	
	CalCalendar *calendar;
	
	NSString *calendarId = Param1.copyUTF16String();
	NSString *startDateString = Param2.copyUTF16String();
	NSString *endDateString = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValueInternal);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValueInternal);
		if(calendar){
			CalEvent *event = [CalEvent event];
			NSDate *startDate = iCal::getDate(startDateString, returnValueInternal);
			NSDate *endDate = iCal::getDate(endDateString, returnValueInternal);
			if((startDate) && (endDate)){
				event.startDate = startDate;
				event.endDate = endDate;
				if(Param4.getSize() == Param5.getSize()){
					unsigned int len = Param4.getSize();
					for (unsigned int i = 0; i < len;++i){
						CUTF16String _key, _value;
						Param4.copyUTF16StringAtIndex(&_key, i);
						Param5.copyUTF16StringAtIndex(&_value, i);
						NSString *key = [[NSString alloc]initWithCharacters:(const unichar *)_key.c_str() length:_key.length()];
						NSString *value = [[NSString alloc]initWithCharacters:(const unichar *)_value.c_str() length:_value.length()];
						iCal::setEventProperty(event, key, value);
						[key release];
						[value release];
					}
				}
				event.calendar = calendar;
				if(![defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error]){
					NSLog(@"can't save event: %@", [error localizedDescription]);
				}else{
					returnValue.setUTF16String([event uid]);
				}
			}else{
				NSLog(@"invalid start date: %@, end date: %@", startDateString, endDateString);
			}
		}else{
			NSLog(@"invalid calendar: %@", calendarId);
		}
	}
	
	[calendarId release];
	[startDateString release];
	[endDateString release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	NSString *date = Param4.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:[NSDate dateWithString:date]];
		if(event){
			iCal::setEventProperty(event, key, value);
			success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[key release];
	[value release];
	[date release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				iCal::recordSpecifier.date = Param4.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getEventProperty, 0, @"$iCal_Get_event_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				[iCal::recordSpecifier.date release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);

}

void iCal_Remove_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			success = [defaultCalendarStore removeEvent:event span:CalSpanAllEvents error:&error];
			if(error){
				success = [error code];
				NSLog(@"can't remove event: %@", [error localizedDescription]);
			}
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_properties(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *date = Param4.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:[NSDate dateWithString:date]];
		if(event){
			
			if(Param2.getSize() == Param3.getSize()){
				unsigned int len = Param2.getSize();
				for (unsigned int i = 0; i < len;++i){
					CUTF16String _key, _value;
					Param2.copyUTF16StringAtIndex(&_key, i);
					Param3.copyUTF16StringAtIndex(&_value, i);
					NSString *key = [[NSString alloc]initWithCharacters:(const unichar *)_key.c_str() length:_key.length()];
					NSString *value = [[NSString alloc]initWithCharacters:(const unichar *)_value.c_str() length:_value.length()];
					iCal::setEventProperty(event, key, value);
					[key release];
					[value release];
				}
				success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
			}
			
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[date release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Task

void iCal_Create_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSError *error = nil;
	
	CalCalendar *calendar;
	
	NSString *calendarId = Param1.copyUTF16String();
	NSString *dueDateString = Param2.copyUTF16String();
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, _returnValue);
		if(calendar){
			CalTask *task = [CalTask task];
			task.calendar = calendar;
			
			NSDate *dueDate = [NSDate dateWithString:dueDateString];
			
			if(dueDate) task.dueDate = dueDate;
			
			[defaultCalendarStore saveTask:task error:&error];
			
			if(error){
				NSLog(@"can't save task: %@", [error localizedDescription]);
			}else{
				returnValue.setUTF16String([task uid]);
			}
		}
	}
	
	[calendarId release];
	[dueDateString release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalTask *task = [defaultCalendarStore taskWithUID:uid];
		NSArray *taskProperties = [NSArray arrayWithObjects:
															 @"dueDate", @"isCompleted",
															 @"priority", @"completedDate" ,
															 @"hasAlarm", @"nextAlarmDate",
															 @"calendar", @"dateStamp",
															 @"notes", @"title",
															 @"url", nil];
		if(task){
			NSUInteger pid = [taskProperties indexOfObject:key];
			
			switch (pid){
				case 0://dueDate
					task.dueDate = [NSDate dateWithString:value];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 1://isCompleted
					task.isCompleted = [value boolValue];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 2://priority
					task.priority = [value integerValue];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 3://completedDate
					task.completedDate = [NSDate dateWithString:value];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 4://hasAlarm (readonly)
					break;
				case 5://nextAlarmDate (readonly)
					break;
				case 6://calendar
				{
					CalCalendar *calendar = [defaultCalendarStore calendarWithUID:value];
					if(calendar){
						task.calendar = calendar;
						success = [defaultCalendarStore saveTask:task error:&error];
					}
				}
					break;
				case 7://dateStamp (readonly)
					break;
				case 8://notes
					task.notes = value;
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 9://title
					task.title = value;
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 10://url
				{
					NSURL *url = [NSURL URLWithString:value];
					if(url){
						task.url = url;
						success = [defaultCalendarStore saveTask:task error:&error];
					}
				}
					break;
					
				default:
					break;
			}
			
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update task: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getTaskProperty, 0, @"$iCal_Get_task_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				[iCal::recordSpecifier.date release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString * taskId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [[CalCalendarStore defaultCalendarStore]taskWithUID:taskId];
		
		if(task) success = [[CalCalendarStore defaultCalendarStore]removeTask:task error:&error];
		
		if(error){
			success = [error code];
			NSLog(@"can't remove task: %@", [error localizedDescription]);
		}
	}
	
	[taskId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		if(task){
			int count = [[task alarms]count];
			int index = Param2.getIntValue();
			
			if((count >= index) && (index > 0)){
				CalAlarm *alarm = [[task alarms]objectAtIndex:(NSUInteger)(index - 1)];
				[task removeAlarm:alarm];
				success = 1;
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
			
		}else{
			success = [error code];
			NSLog(@"invalid task: %@", taskId);
		}
	}
	
	[taskId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	NSString *dictionary = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		if(task){
			
			int count = [[task alarms]count];
			int index = Param2.getIntValue();
			
			if((count >= index) && (index > 0)){
				
				NSMutableArray *alarms = [[task alarms]mutableCopy];
				CalAlarm *newAlarm = iCal::getAlarmFromString(dictionary);
				
				if(newAlarm){
					[alarms replaceObjectAtIndex:(NSUInteger)(index - 1) withObject:newAlarm];
					[task removeAlarms:[task alarms]];
					[task addAlarms:alarms];
					success = [defaultCalendarStore saveTask:task error:&error];
				}
				
				[alarms release];
				
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
			
		}else{
			success = [error code];
			NSLog(@"invalid task: %@", taskId);
		}
	}
	
	[taskId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Calendar

void iCal_Create_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSError *error = nil;
	
	NSString *title = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	NSColor *color;
	
	CalCalendar *calendar = [CalCalendar calendar];
	
	calendar.title = title;
	
	color = iCal::getColorFromString(dictionary);
	if(color)	calendar.color = color;
	
	[[CalCalendarStore defaultCalendarStore]saveCalendar:calendar error:&error];
	
	if(error){
		NSLog(@"can't save calendar: %@", [error localizedDescription]);
	}else{
		returnValue.setUTF16String([calendar uid]);
	}
	
	[title release];
	[dictionary release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_calendar_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	CalCalendar *calendar;
	
	NSString * calendarId = Param1.copyUTF16String();
	NSString * key = Param2.copyUTF16String();
	NSString * value = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if (defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValue);
		if(calendar){
			NSColor *color;
			
			NSArray *calendarProperties = [NSArray arrayWithObjects:
																		 @"color", @"isEditable",
																		 @"notes", @"title",
																		 @"type", nil];
			NSUInteger pid = [calendarProperties indexOfObject:key];
			switch (pid){
				case 0://color
					color = iCal::getColorFromString(value);
					if(color){
						calendar.color = color;
						success = [defaultCalendarStore saveCalendar:calendar error:&error];
					}
					break;
				case 1://isEditable (readonly)
					break;
				case 2://notes
					calendar.notes = value;
					success = [defaultCalendarStore saveCalendar:calendar error:&error];
					break;
				case 3://title
					calendar.title = value;
					success = [defaultCalendarStore saveCalendar:calendar error:&error];
					break;
				case 4://type (readonly)
					break;
				default:
					break;
			}
			if(error){
				success = [error code];
				NSLog(@"can't update calendar: %@", [error localizedDescription]);
			}
		}
	}
	
	[calendarId release];
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_calendar_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getCalendarProperty, 0, @"$iCal_Get_calendar_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
		
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	CalCalendar *calendar;
	
	NSString * calendarId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValue);
		if(calendar){
			success = [defaultCalendarStore removeCalendar:calendar error:&error];
			if(error){
				success = [error code];
				NSLog(@"can't remove calendar: %@", [error localizedDescription]);
			}
		}
	}
	
	[calendarId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Query


void iCal_QUERY_EVENT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	ARRAY_TEXT Param3;
	ARRAY_TEXT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		
		NSString *startDateString = Param1.copyUTF16String();
		NSString *endDateString = Param2.copyUTF16String();
		NSDate *startDate = [NSDate dateWithString:startDateString];
		NSDate *endDate = [NSDate dateWithString:endDateString];
		NSArray *calendars = iCal::getCalendars(defaultCalendarStore, Param3);
		[startDateString release];
		[endDateString release];
		
		NSPredicate *predicate;
		
		if((startDate) && (endDate)){
			
			predicate = [CalCalendarStore eventPredicateWithStartDate:startDate endDate:endDate calendars:calendars];
			
			Param4.appendUTF16String(@"");
			
			if(predicate){
				NSArray *events = [[CalCalendarStore defaultCalendarStore]eventsWithPredicate:predicate];
				for(unsigned int i = 0; i < [events count]; ++i){
					Param4.appendUTF16String([[events objectAtIndex:i]uid]);
				}
			}
		}
	}
	Param4.toParamAtIndex(pParams, 4);
}

void iCal_GET_CALENDAR_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	ARRAY_TEXT Param2;
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		NSArray *calendars = [defaultCalendarStore calendars];
		Param1.appendUTF16String(@"");
		Param2.appendUTF16String(@"");
		for(unsigned int i = 0; i < [calendars count]; ++i){
			Param1.appendUTF16String([[calendars objectAtIndex:i]uid]);
			Param2.appendUTF16String([[calendars objectAtIndex:i]title]);
		}
	}
	
	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
}

void iCal_QUERY_TASK(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	C_LONGINT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param4.fromParamAtIndex(pParams, 4);
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		
		NSString *dueDateString = Param1.copyUTF16String();
		NSDate *dueDate = [NSDate dateWithString:dueDateString];
		[dueDateString release];
		
		NSArray *calendars = iCal::getCalendars(defaultCalendarStore, Param2);
		
		NSPredicate *predicate;
		
		switch (Param4.getIntValue()){
			case 1:
				if(dueDate){
					predicate = [CalCalendarStore taskPredicateWithTasksCompletedSince:dueDate calendars:calendars];
				}else{
					predicate = [CalCalendarStore taskPredicateWithTasksCompletedSince:[NSDate distantPast] calendars:calendars];
				}
				break;
			default:
				if(dueDate){
					predicate = [CalCalendarStore taskPredicateWithUncompletedTasksDueBefore:dueDate calendars:calendars];
				}else{
					predicate = [CalCalendarStore taskPredicateWithUncompletedTasks:calendars];
				}
				break;
		}
		
		Param3.appendUTF16String(@"");
		
		if(predicate){
			NSArray *tasks = [defaultCalendarStore tasksWithPredicate:predicate];
			for(unsigned int i = 0; i < [tasks count]; ++i){
				Param3.appendUTF16String([[tasks objectAtIndex:i]uid]);
			}
		}
	}
	Param3.toParamAtIndex(pParams, 3);
}

#pragma mark Type Cast

void iCal_Make_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_TEXT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	PA_Date date;
	date.fYear = Param1.getYear();
	date.fMonth = Param1.getMonth();
	date.fDay = Param1.getDay();
	
	int seconds = Param2.getSeconds();
	NSString *name = Param3.copyUTF16String();
	
	NSString *description = iCal::copyDateTimeZoneString(&date, seconds, name);
	
	returnValue.setUTF16String(description);
	returnValue.setReturn(pResult);
	
	[description release];
	[name release];
}

void iCal_GET_DATE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *dateString = Param1.copyUTF16String();
	
	PA_Date date;
	int time = 0;
	int offset = 0;
	
	iCal::getDateTimeOffsetFromString(dateString, &date, &time, &offset);
	
	Param2.setYearMonthDay(date.fYear, date.fMonth, date.fDay);
	Param3.setSeconds(time);
	Param4.setIntValue(offset);
	
	[dateString release];
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
}

void iCal_Make_color(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_REAL Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	float red = Param1.getDoubleValue();
	float green = Param2.getDoubleValue();
	float blue = Param3.getDoubleValue();
	float alpha = Param4.getDoubleValue();
	
	NSColor *color = [NSColor colorWithDeviceRed:red green:green blue:blue alpha:alpha];
	NSString *colorString = iCal::copyColorString(color);
	
	returnValue.setUTF16String(colorString);
	returnValue.setReturn(pResult);
	
	[colorString release];
}

void iCal_GET_COLOR(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_REAL Param5;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *colorString = Param1.copyUTF16String();
	NSColor *color = iCal::getColorFromString(colorString);
	
	Param2.setDoubleValue((double)[color redComponent]);
	Param3.setDoubleValue((double)[color greenComponent]);
	Param4.setDoubleValue((double)[color blueComponent]);
	Param5.setDoubleValue((double)[color alphaComponent]);
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	
	[colorString release];
}

void iCal_Make_color_from_index(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSColor *color = iCal::getColorIndex(Param1.getIntValue());
	NSString *colorString = iCal::copyColorString(color);
	
	returnValue.setUTF16String(colorString);
	returnValue.setReturn(pResult);
	
	[colorString release];
}

#pragma mark Recurrence Rule

void iCal_Remove_event_recurrence(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			event.recurrenceRule = nil;
			success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:NULL];
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_recurrence(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_TEXT Param5;
	C_TEXT Param6;
	C_TEXT Param7;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);
	Param6.fromParamAtIndex(pParams, 6);
	Param7.fromParamAtIndex(pParams, 7);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *type = Param2.copyUTF16String();
	NSUInteger interval = Param3.getIntValue();
	NSString *dateString = Param4.copyUTF16String();
	NSString *param1 = Param5.copyUTF16String();
	NSString *param2 = Param6.copyUTF16String();
	NSString *param3 = Param7.copyUTF16String();
	NSDate *date = [NSDate dateWithString:dateString];
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			
			NSArray *ruleTypes = [NSArray arrayWithObjects:
														@"Daily", @"Weekly", @"Monthly", @"Yearly", nil];
			NSUInteger pid = [ruleTypes indexOfObject:type];
			CalRecurrenceRule *rule;
			NSArray *days;
			NSArray *months;
			
			switch (pid){
				case 0://Daily
					if(date){
						rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
					}else{
						if([dateString length]){
							rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
						}else{
							rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:nil];
						}
					}
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
				case 1://Weekly
					days = [param1 componentsSeparatedByString:@","];
					if([days count]){
						if(date){
							rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:nil];
							}
						}
					}else{
						if(date){
							rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:nil];
							}
						}
					}
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
				case 2://Monthly
					days = [param1 componentsSeparatedByString:@","];
					if([days count]){
						if(date){
							rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:nil];
							}
						}
					}else{
						
						if(([param1 length])&&([param2 length])){
							if(date){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:nil];
								}
							}
						}else{
							if(date){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:nil];
								}
							}
						}
					}
					
				case 3://Yearly
					days = [param1 componentsSeparatedByString:@","];
					months = [param3 componentsSeparatedByString:@","];
					if([months count]){
						
						if(date){
							rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:nil];
							}
						}
						
					}else{
						if([days count]){
							if(date){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:nil];
								}
							}
						}else{
							if(date){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:nil];
								}
							}
						}
					}
					
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
			}
			if(error){
				success = [error code];
				NSLog(@"can't update event: %@", [error localizedDescription]);
			}
		}
	}
	
	[uid release];
	[type release];
	[dateString release];
	[param1 release];
	[param2 release];
	[param3 release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Alarm

void iCal_Make_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	CalAlarm *alarm = [CalAlarm alarm];
	NSString *alarmString = iCal::copyAlarmString(alarm);
	
	returnValue.setUTF16String(alarmString);
	returnValue.setReturn(pResult);
	
	[alarmString release];
}

void iCal_Get_alarm_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();

				iCal::newProcess((void *)iCal::getAlarmProperty, 0, @"$iCal_Get_alarm_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}

				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_alarm_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSString *dictionary = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	
	CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
	
	NSArray *alarmProperties = [NSArray arrayWithObjects:
															@"action", @"absoluteTrigger",
															@"emailAddress", @"relativeTrigger" ,
															@"sound", @"url", nil];
	
	if(alarm){
		
		NSUInteger pid = [alarmProperties indexOfObject:key];
		NSDate *d = nil;
		NSURL *u = nil;
		
		switch (pid){
				
			case 0://action
				alarm.action = value;
				success = 1;
				break;
			case 1://absoluteTrigger
				d = [NSDate dateWithString:value];
				if(d){
					alarm.absoluteTrigger = d;
					success = 1;
				}
				break;
			case 2://emailAddress
				alarm.emailAddress = value;
				success = 1;
				break;
			case 3://relativeTrigger
				alarm.relativeTrigger = [value doubleValue];
				success = 1;
				break;
			case 4://sound
				alarm.sound = value;
				success = 1;
				break;
			case 5://url
				u = [[NSURL alloc]initWithString:value];
				if(u){
					if([u isFileURL]){
						alarm.url = u;
						success = 1;
					}
					[u release];
				}
				break;
		}
	}
	
	[dictionary release];
	dictionary = iCal::copyAlarmString(alarm);
	Param1.setUTF16String(dictionary);
	Param1.toParamAtIndex(pParams, 1);
	[dictionary release];
	
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Add_alarm_to_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSString *eventId = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	
	int success = 0;
	
	NSError *error = nil;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:eventId occurrence:nil];
		CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
		if(event){
			[event addAlarm:alarm];
			success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[eventId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Add_alarm_to_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
		
		if(task){
			[task addAlarm:alarm];
			success = [defaultCalendarStore saveTask:task error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update task: %@", [error localizedDescription]);
		}
		
	}
	
	[taskId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.index = Param2.getIntValue();
				
				iCal::newProcess((void *)iCal::getEventAlarm, 0, @"$iCal_Get_event_alarm");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Count_event_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				
				iCal::newProcess((void *)iCal::countEventAlarms, 0, @"$iCal_Count_event_alarms");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param2.setIntValue(iCal::recordSpecifier.count);
					Param2.toParamAtIndex(pParams, 2);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			int count = [[event alarms]count];
			int index = Param2.getIntValue();
			if((count >= index) && (index > 0)){
				CalAlarm *alarm = [[event alarms]objectAtIndex:(NSUInteger)(index - 1)];
				[event removeAlarm:alarm];
				success = 1;
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *dictionary = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			int count = [[event alarms]count];
			int index = Param2.getIntValue();
			if((count >= index) && (index > 0)){
				NSMutableArray *alarms = [[event alarms]mutableCopy];
				CalAlarm *newAlarm = iCal::getAlarmFromString(dictionary);
				if(newAlarm){
					[alarms replaceObjectAtIndex:(NSUInteger)(index - 1) withObject:newAlarm];
					[event removeAlarms:[event alarms]];
					[event addAlarms:alarms];
					success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
				}
				[alarms release];
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
		}
	}
	
	[uid release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Count_task_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				
				iCal::newProcess((void *)iCal::countTaskAlarms, 0, @"$iCal_Count_task_alarms");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param2.setIntValue(iCal::recordSpecifier.count);
					Param2.toParamAtIndex(pParams, 2);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.index = Param2.getIntValue();
				
				iCal::newProcess((void *)iCal::getTaskAlarm, 0, @"$iCal_Get_task_alarm");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Application

void iCal_TERMINATE(sLONG_PTR *pResult, PackagePtr pParams){
	//requires 10.6 or later
	
	if(NSClassFromString(@"NSRunningApplication")){
		NSArray *array = [NSRunningApplication runningApplicationsWithBundleIdentifier:@"com.apple.iCal"];
		if([array count])
			[(NSRunningApplication *)[array objectAtIndex:0] terminate];
	}
}

void iCal_LAUNCH(sLONG_PTR *pResult, PackagePtr pParams){
	[[NSWorkspace sharedWorkspace]launchApplication:@"iCal"];
}

void iCal_SHOW_EVENT(sLONG_PTR *pResult, PackagePtr pParams){
	
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *eventId = Param1.copyUTF16String();
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:eventId occurrence:nil];
		if(event){
			NSString *calendarId =event.calendar.uid;
			iCal::appleScriptExecuteFunction(@"show_event", @"show_event", calendarId, eventId, nil);
		}
	}
	[eventId release];
}

void iCal_SHOW_TASK(sLONG_PTR *pResult, PackagePtr pParams){
	
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *taskId = Param1.copyUTF16String();
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	if(defaultCalendarStore){
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		if(task){
			NSString *calendarId =task.calendar.uid;
			iCal::appleScriptExecuteFunction(@"show_task", @"show_task", calendarId, taskId, nil);
		}
	}
	[taskId release];
}

void iCal_SET_VIEW(sLONG_PTR *pResult, PackagePtr pParams){
	
	BOOL useAppleScript = false;
	
	if(useAppleScript)
	{
		C_LONGINT Param1;
		
		Param1.fromParamAtIndex(pParams, 1);
		
		switch (Param1.getIntValue()){
			case 0:
				iCal::appleScriptExecuteFunction(@"switch_view", @"switch_view", @"Day", nil, nil);
				break;
			case 1:
				iCal::appleScriptExecuteFunction(@"switch_view", @"switch_view", @"Week", nil, nil);
				break;
			case 2:
				iCal::appleScriptExecuteFunction(@"switch_view", @"switch_view", @"Month", nil, nil);
				break;
			default:
				break;
		}
	}
	
	//using SBApplication in main thread was crashing 4D cocoa on quit (autoreleasepool violation)
	iCalApplication *iCal = [SBApplication applicationWithBundleIdentifier:@"com.apple.iCal"];
	
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	switch (Param1.getIntValue()){
		case 0:
			[iCal switchViewTo:iCalCALViewTypeForScriptingDayView];
			break;
		case 1:
			[iCal switchViewTo:iCalCALViewTypeForScriptingWeekView];
			break;
		case 2:
			[iCal switchViewTo:iCalCALViewTypeForScriptingMonthView];
			break;
		default:
			break;
	}
	
}

void iCal_SHOW_DATE(sLONG_PTR *pResult, PackagePtr pParams){
	
	C_DATE Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *yearValue = [[NSNumber numberWithShort:Param1.getYear()]stringValue];
	NSString *monthValue = [[NSNumber numberWithShort:Param1.getMonth()]stringValue];
	NSString *dayValue = [[NSNumber numberWithShort:Param1.getDay()]stringValue];
	
	iCal::appleScriptExecuteFunction(@"show_date", @"show_date", yearValue, monthValue, dayValue);
}

#pragma mark Not Implemented

void iCal_app_Get_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	// --- write the code of iCal_app_Get_task_property here...

	returnValue.setReturn(pResult);
}

void iCal_app_Get_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	// --- write the code of iCal_app_Get_event_property here...

	returnValue.setReturn(pResult);
}

#pragma mark -

// --------------------------------- Notification ---------------------------------

void get_calendar_paths(ARRAY_TEXT &paths)
{
	@autoreleasepool
	{
		NSString *userCalendarPath = [NSString stringWithFormat:@"%@/Calendars/",
																	[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)
																	 objectAtIndex:0]];
		
		ARRAY_TEXT uids;
		ARRAY_TEXT titles;
		
		paths.setSize(1);
		uids.setSize(1);
		titles.setSize(1);
		
		sqlite3_get_calendars([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], uids, titles);
		
		NSUInteger size = uids.getSize();
		
		for(NSUInteger i = 0; i < size; ++i)
		{
			CUTF8String calendar_uid, group_uid;
			uids.copyUTF8StringAtIndex(&calendar_uid, i);
			
			sqlite3_get_calendar_group_uid([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], calendar_uid, group_uid);
			
			NSFileManager *defaultManager = [[NSFileManager alloc]init];
			
			NSString *path_caldav = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".caldav", calendar_uid.c_str(), ".calendar"];
			NSString *path_exchange = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".exchange", calendar_uid.c_str(), ".calendar"];
			
			BOOL isDirectory;
			if(([defaultManager fileExistsAtPath:path_caldav isDirectory:&isDirectory]) && isDirectory)
			{
				paths.appendUTF16String([NSString stringWithFormat:@"%@/Events/", path_caldav]);
			}
			else if(([defaultManager fileExistsAtPath:path_exchange isDirectory:&isDirectory]) && isDirectory)
			{
				paths.appendUTF16String([NSString stringWithFormat:@"%@/Events/", path_exchange]);
			}
			[defaultManager release];
		}
		
	}//@autoreleasepool
}

void iCal_Set_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT methodName;
	C_LONGINT returnValue;
	
	methodName.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	if(!methodName.getUTF16Length())
	{
		CalendarWatch::removeAllFromWatch();
		iCal::listenerMethodName.setUTF16String(methodName.getUTF16StringPtr(), methodName.getUTF16Length());
		success = 1;

	}else{
		
		method_id_t methodId = PA_GetMethodID((PA_Unichar *)methodName.getUTF16StringPtr());
		if(methodId)
		{
			CalendarWatch::removeAllFromWatch();
			
			ARRAY_TEXT paths;
			get_calendar_paths(paths);
			
			for(NSUInteger i = 1; i < paths.getSize(); ++i)
			{
				CUTF8String path;
				paths.copyUTF8StringAtIndex(&path, i);
				CalendarWatch::addToWatch(path, methodId);
			}
			
			iCal::listenerMethodName.setUTF16String(methodName.getUTF16StringPtr(), methodName.getUTF16Length());

			success = 1;
		}
	}
	
	returnValue.setReturn(pResult);
}

void iCal_Get_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;
	returnValue.setIntValue(1);
	returnValue.setReturn(pResult);
	
	iCal::listenerMethodName.toParamAtIndex(pParams, 1);
}

#pragma mark Timezone

void iCal_TIMEZONE_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	
	NSArray *knownTimeZoneNames = [NSTimeZone knownTimeZoneNames];
	
	Param1.appendUTF16String(@"");
	
	for(unsigned int i = 0; i < [knownTimeZoneNames count]; i++)
	{
		Param1.appendUTF16String([knownTimeZoneNames objectAtIndex:i]);
	}
	
	Param1.toParamAtIndex(pParams, 1);
}

void iCal_Get_timezone_info(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_TEXT Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_DATE Param6;
	C_TIME Param7;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	NSString *name = Param3.copyUTF16String();
	NSTimeZone *zone = [NSTimeZone timeZoneWithName:name];
	if(!zone)
		zone = [NSTimeZone localTimeZone];
	[name release];
	
	CFGregorianDate gregDate;
	
	gregDate.year = Param1.getYear();
	gregDate.month = Param1.getMonth();
	gregDate.day = Param1.getDay();
	gregDate.hour = 0;
	gregDate.minute = 0;
	gregDate.second = 0;
	
	CFGregorianUnits offset;
	
	offset.years = 0;
	offset.months = 0;
	offset.days = 0;
	offset.minutes = 0;
	offset.hours = 0;
	offset.seconds = Param2.getSeconds();
	
	NSTimeInterval daylightSavingTimeOffsetForDate;
	NSInteger secondsFromGMTForDate;
	NSDate *nextDaylightSavingTimeTransitionAfterDate;
	
	if(CFGregorianDateIsValid(gregDate,
														kCFGregorianUnitsYears+kCFGregorianUnitsMonths+kCFGregorianUnitsDays)){
		
		CFAbsoluteTime at = CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)zone);
		CFAbsoluteTime seconds = CFAbsoluteTimeAddGregorianUnits(at, (CFTimeZoneRef)zone, offset);
		
		NSDate *nsd = (NSDate *)CFDateCreate(kCFAllocatorDefault, seconds);
		
		daylightSavingTimeOffsetForDate = [zone daylightSavingTimeOffsetForDate:nsd];
		secondsFromGMTForDate = [zone secondsFromGMTForDate:nsd];
		nextDaylightSavingTimeTransitionAfterDate = [zone nextDaylightSavingTimeTransitionAfterDate:nsd];
		
		[nsd release];
		
		Param4.setIntValue(secondsFromGMTForDate);
		Param5.setIntValue(daylightSavingTimeOffsetForDate);
		
		NSString *description = [nextDaylightSavingTimeTransitionAfterDate description];
		
		if([description length] == 25){
			
			int year = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
			int month = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
			int day = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
			
			int hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
			int minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
			int second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
			
			int offset = [zone secondsFromGMTForDate:nextDaylightSavingTimeTransitionAfterDate];
			
			Param6.setYearMonthDay(year, month, day);
			Param7.setSeconds(second + (minute * 60) + (hour * 3600) - offset);
			returnValue.setIntValue(1);
			
		}
		
	}
	
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
	Param7.toParamAtIndex(pParams, 7);
	returnValue.setReturn(pResult);
}

void iCal_Get_timezone_for_offset(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	returnValue.setUTF16String([[NSTimeZone timeZoneForSecondsFromGMT:Param1.getIntValue()]name]);
	
	returnValue.setReturn(pResult);
}

void iCal_Get_system_timezone(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	returnValue.setUTF16String([[NSTimeZone systemTimeZone]name]);
	
	returnValue.setReturn(pResult);
}


