/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : iCal
 #	author : miyako
 #	2016/10/03
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define CALLBACK_IN_NEW_PROCESS 1
#define CALLBACK_SLEEP_TIME 59

std::mutex mutexSqlite;

std::mutex globalMutex; /* CALLBACK_EVENT_IDS */
std::mutex globalMutex0;/* shouldPresentNotification */
std::mutex globalMutex1;/* for MONITOR_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

#pragma mark UserInfo

class UserInfo
{
private:
    
    notification_t _notification;
    CUTF8String _uid;
    
public:
    
    UserInfo(notification_t notification, NSString *event_uid);
    
    void get(notification_t *notification, CUTF16String &event);
    
    ~UserInfo();
};

UserInfo::UserInfo(notification_t notification, NSString *event_uid)
{
    this->_notification = notification;
    if(event_uid)
    {
        this->_uid = CUTF8String((const uint8_t *)[event_uid UTF8String]);
    }
}

void UserInfo::get(notification_t *notification, CUTF16String &event)
{
    *notification = this->_notification;
    
    C_TEXT t;
    t.setUTF8String(&this->_uid);
    t.copyUTF16String(&event);
}

UserInfo::~UserInfo()
{
    
}

namespace CalendarWatch
{
    Listener *listener = nil;
    
    const process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
    const process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0_\0W\0A\0T\0C\0H\0\0\0";
    
    std::vector<CUTF8String> paths;
    std::vector<UserInfo> notifications;
    
    FSEventStreamRef eventStream = 0;
    NSTimeInterval latency = 1.0;
    
    //callback management
    C_TEXT WATCH_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE;
    bool PROCESS_SHOULD_RESUME = false;
}

#pragma mark -

const char *sql_get_calendar_group_uid = "SELECT\n\
ZUID\n\
FROM ZNODE\n\
WHERE Z_PK ==\n\
(\n\
SELECT ZGROUP\n\
FROM  ZNODE\n\
WHERE ZUID == ?\n\
LIMIT 1\n\
);";

const char *sql_get_calendars = "SELECT\n\
ZUID, ZTITLE\n\
FROM ZNODE\n\
WHERE ZISTASKCONTAINER != 1\n\
AND ZGROUP != '';";

void sqlite3_get_calendar_group_uid(NSString *userCalendarPath,
                                    CUTF8String &calendar_uid,
                                    CUTF8String &group_uid)
{
    
    std::lock_guard<std::mutex> lock(mutexSqlite);
    
    sqlite3 *sqlite3_calendar = NULL;
    
    int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
    
    if(err != SQLITE_OK)
    {
        NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
    }else
    {
        sqlite3_stmt *sql = NULL;
        err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendar_group_uid, 1024, &sql, NULL);
        if(err != SQLITE_OK)
        {
            NSLog(@"failed to prepare sqlite statement");
        }else
        {
            sqlite3_bind_text(sql, 1, (const char *)calendar_uid.c_str(), calendar_uid.length(), NULL);
            
            while(SQLITE_ROW == (err = sqlite3_step(sql)))
            {
                const unsigned char *_group_uid = sqlite3_column_text(sql, 0);
                if(_group_uid)
                {
                    group_uid = CUTF8String(_group_uid, strlen((const char *)_group_uid));
                }
            }
            sqlite3_finalize(sql);
        }
        sqlite3_close(sqlite3_calendar);
    }
}

void sqlite3_get_calendars(NSString *userCalendarPath,
                           ARRAY_TEXT &uids,
                           ARRAY_TEXT &titles)
{
    std::lock_guard<std::mutex> lock(mutexSqlite);
    
    sqlite3 *sqlite3_calendar = NULL;
    
    int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
    
    if(err != SQLITE_OK)
    {
        NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
    }else
    {
        sqlite3_stmt *sql = NULL;
        err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendars, 1024, &sql, NULL);
        if(err != SQLITE_OK)
        {
            NSLog(@"failed to prepare sqlite statement");
        }else
        {
            while(SQLITE_ROW == (err = sqlite3_step(sql)))
            {
                const unsigned char *_calendar_uid = sqlite3_column_text(sql, 0);
                const unsigned char *_title = sqlite3_column_text(sql, 1);
                
                if(_calendar_uid)
                {
                    if(_title)
                    {
                        uids.appendUTF8String(_calendar_uid, strlen((const char *)_calendar_uid));
                        titles.appendUTF8String(_title, strlen((const char *)_title));
                    }
                    
                }
            }
            sqlite3_finalize(sql);
        }
        sqlite3_close(sqlite3_calendar);
    }
}

#pragma mark -

void gotEvent(FSEventStreamRef stream,
              void *callbackInfo,
              size_t numEvents,
              void *eventPaths,
              const FSEventStreamEventFlags eventFlags[],
              const FSEventStreamEventId eventIds[]
              )
{
    
    @autoreleasepool
    {
        NSArray *paths_ns = (NSArray *)eventPaths;
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"([:HexDigit:]{8}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{12})\\.ics$"
                                                                               options:NSRegularExpressionCaseInsensitive
                                                                                 error:nil];
        if(regex)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            for(NSUInteger i = 0; i < numEvents; ++i)
            {
                NSString *path_ns = [paths_ns objectAtIndex:i];
                
                NSArray *matches = [regex matchesInString:path_ns
                                                  options:0
                                                    range:NSMakeRange(0, [path_ns length])];
                
                for (NSTextCheckingResult *match in matches)
                {
                    NSString *event_uid = [path_ns substringWithRange:[match rangeAtIndex:1]];
                    FSEventStreamEventFlags flags = eventFlags[i];
                    
                    NSLog(@"flags:%d", (unsigned int)flags);
                    
                    if((flags & kFSEventStreamEventFlagItemIsFile) == kFSEventStreamEventFlagItemIsFile)
                    {
                        if((flags & kFSEventStreamEventFlagItemRemoved) == kFSEventStreamEventFlagItemRemoved)
                        {
                            NSLog(@"removed calendar item:\t%@", event_uid);
                            UserInfo userInfo(notification_delete, event_uid);
                            CalendarWatch::notifications.push_back(userInfo);
                        }
                        else if((flags & kFSEventStreamEventFlagItemCreated) == kFSEventStreamEventFlagItemCreated)
                        {
                            if(((flags & kFSEventStreamEventFlagItemModified) == kFSEventStreamEventFlagItemModified)
                               ||((flags & kFSEventStreamEventFlagItemInodeMetaMod) == kFSEventStreamEventFlagItemInodeMetaMod))
                            {
                                NSLog(@"modified calendar item:\t%@", event_uid);
                                UserInfo userInfo(notification_update, event_uid);
                                CalendarWatch::notifications.push_back(userInfo);
                            }else{
                                NSLog(@"created calendar item:\t%@", event_uid);
                                UserInfo userInfo(notification_create, event_uid);
                                CalendarWatch::notifications.push_back(userInfo);
                            }
                        }
                        else
                        {
                            NSLog(@"modified calendar item:\t%@", event_uid);
                            UserInfo userInfo(notification_update, event_uid);
                            CalendarWatch::notifications.push_back(userInfo);
                        }
                    }
                }
            }
        }
    }//@autoreleasepool
    listenerLoopExecute();
}

@implementation Listener

- (id)init
{
    if(!(self = [super init])) return self;
    
    /* setup object instance here */
    
    stream = 0;

    return self;
}

- (void)dealloc
{
    if(stream)
    {
        FSEventStreamStop(stream);
        FSEventStreamUnscheduleFromRunLoop (stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        FSEventStreamInvalidate(stream);
        FSEventStreamRelease(stream);
        stream = 0;
    }
    
    [super dealloc];
}

- (void)setPaths
{
    NSMutableArray *paths = [[NSMutableArray alloc]init];
    
    @autoreleasepool
    {
        NSString *userCalendarPath = [NSString stringWithFormat:@"%@/Calendars/",
                                      [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)
                                       objectAtIndex:0]];
        ARRAY_TEXT uids;
        ARRAY_TEXT titles;
        
        sqlite3_get_calendars([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], uids, titles);
        
        NSUInteger size = uids.getSize();
        
        for(NSUInteger i = 0; i < size; ++i)
        {
            CUTF8String calendar_uid, group_uid;
            uids.copyUTF8StringAtIndex(&calendar_uid, i);
            
            sqlite3_get_calendar_group_uid([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], calendar_uid, group_uid);
            
            NSFileManager *defaultManager = [[NSFileManager alloc]init];
            
            NSString *path_caldav = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".caldav", calendar_uid.c_str(), ".calendar"];
            NSString *path_exchange = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".exchange", calendar_uid.c_str(), ".calendar"];
            
            BOOL isDirectory;
            if(([defaultManager fileExistsAtPath:path_caldav isDirectory:&isDirectory]) && isDirectory)
            {
                [paths addObject:[NSString stringWithFormat:@"%@/Events/", path_caldav]];
            }
            else if(([defaultManager fileExistsAtPath:path_exchange isDirectory:&isDirectory]) && isDirectory)
            {
                [paths addObject:[NSString stringWithFormat:@"%@/Events/", path_caldav]];
            }
            [defaultManager release];
        }
        
    }//@autoreleasepool
    
    if([paths count])
    {
        FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
        NSTimeInterval latency = CalendarWatch::latency;
        
        stream = FSEventStreamCreate(NULL,
                                     (FSEventStreamCallback)gotEvent,
                                     &context,
                                     (CFArrayRef)paths,
                                     kFSEventStreamEventIdSinceNow,
                                     (CFAbsoluteTime)latency,
                                     kFSEventStreamCreateFlagUseCFTypes
                                     | kFSEventStreamCreateFlagFileEvents
                                     | kFSEventStreamCreateFlagNoDefer
                                     | kFSEventStreamCreateFlagIgnoreSelf
                                     );
        
        NSLog(@"start monitoring paths:%@", [paths description]);
        FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        FSEventStreamStart(stream);
    }
    
    [paths release];
}

@end

#pragma mark -

bool isProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void onCloseProcess()
{
	if(isProcessOnExit())
	{
        listenerLoopFinish();
	}
}

void onStartup()
{

}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

void listener_start()
{
    if(!CalendarWatch::listener)
    {
        CalendarWatch::listener = [[Listener alloc]init];
        [CalendarWatch::listener setPaths];
    }
}

void listener_end()
{
    /* must do this in main process */
    [CalendarWatch::listener release];
    CalendarWatch::listener = nil;
}

#pragma mark -

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        CalendarWatch::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
	PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
//        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = CalendarWatch::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = CalendarWatch::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t EVENT_IDS;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                EVENT_IDS = CalendarWatch::notifications.size();
            }
            
            while(EVENT_IDS)
            {
//                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  CalendarWatch::MONITOR_PROCESS_STACK_SIZE,
                                  (PA_Unichar *)processName.getUTF16StringPtr());
                }else
                {
                    listenerLoopExecuteMethod();
                }
                
                if(PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    EVENT_IDS = CalendarWatch::notifications.size();
                    PROCESS_SHOULD_TERMINATE = CalendarWatch::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                CalendarWatch::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = CalendarWatch::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_TERMINATE)
            break;
        
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        CalendarWatch::notifications.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        CalendarWatch::WATCH_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        CalendarWatch::METHOD_PROCESS_ID = 0;
    }
    
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
    
    PA_KillProcess();
    
}

void listenerLoopStart()
{
    if (!CalendarWatch::METHOD_PROCESS_ID)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);
        
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        CalendarWatch::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                         CalendarWatch::MONITOR_PROCESS_STACK_SIZE,
                                                         CalendarWatch::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
    if(CalendarWatch::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            CalendarWatch::PROCESS_SHOULD_TERMINATE = true;
        }
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            CalendarWatch::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        CalendarWatch::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        CalendarWatch::PROCESS_SHOULD_RESUME = true;
    }
}

void listenerLoopExecuteMethod()
{
    notification_t notification;
    CUTF16String eventId;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        std::vector<UserInfo>::iterator e = CalendarWatch::notifications.begin();
        
        UserInfo userInfo = *e;
        
        userInfo.get(&notification, eventId);
        
        CalendarWatch::notifications.erase(e);
    }
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)CalendarWatch::WATCH_METHOD.getUTF16StringPtr());
    
    if(methodId)
    {
        PA_Variable    params[2];
        params[0] = PA_CreateVariable(eVK_Unistring);
        params[1] = PA_CreateVariable(eVK_Longint);
        PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
        
        PA_SetStringVariable(&params[0], &event);
        PA_SetLongintVariable(&params[1], notification);
        
        PA_ExecuteMethodByID(methodId, params, 2);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
    }else
    {
        PA_Variable    params[3];
        params[1] = PA_CreateVariable(eVK_Unistring);
        params[2] = PA_CreateVariable(eVK_Unistring);
        params[3] = PA_CreateVariable(eVK_Longint);
        PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
        
        PA_SetStringVariable(&params[1], &event);
        PA_SetLongintVariable(&params[2], notification);
        
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)CalendarWatch::WATCH_METHOD.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &method);
        
        /* execute method */
        PA_ExecuteCommandByID(1007, params, 3);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
    }
}

#pragma mark -

namespace iCal
{
	RecordSpecifier recordSpecifier;
	RecordSpecifiers recordSpecifiers;
	
	NSString *copyAttendeesDictionary(NSArray *attendees){
		NSString *attendeesData = nil;
		
		if(attendees)
		{
			CalAttendee *attendee = nil;
			
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			NSMutableArray *array = [[NSMutableArray alloc]init];
			
			unsigned int i;
			
			for (i = 0; i < [attendees count]; i++)
			{
				if([[attendees objectAtIndex:i]isMemberOfClass:[CalAttendee class]])
				{
					attendee = [attendees objectAtIndex:i];
					
					NSString *addressString = nil;
					if(attendee.address)
					{
						addressString = [attendee.address absoluteString];
					}else{
						addressString = @"";
					}
					
					NSString *statusString = nil;
					if(attendee.status)
					{
						statusString = attendee.status;
					}else{
						statusString = @"";
					}
					
					NSString *commonNameString = nil;
					if(attendee.commonName)
					{
						commonNameString = attendee.commonName;
					}else{
						commonNameString = @"";
					}
					
					NSDictionary *item = [NSDictionary
																dictionaryWithObjects:[NSArray arrayWithObjects:statusString, commonNameString, addressString, nil]
																forKeys:[NSArray arrayWithObjects:@"status", @"commonName", @"address", nil]];
					
					[array addObject:item];
					
				}
				
			}
			
			[dictionary setObject:array forKey:@"attendees"];
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			attendeesData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			
			[array release];
			[dictionary release];
			
		}else{attendeesData = @"";}
		
		return attendeesData;
	}
	
	NSArray * getCalendars(CalCalendarStore *calendarStore, NSArray *calendarNames, C_LONGINT &returnValue){
		NSArray *calendars = [calendarStore calendars];
		NSMutableArray *foundCalendars = [NSMutableArray array];
		CalCalendar *calendar;
		unsigned int i, j;
		for(i = 0; i < [calendarNames count]; ++i){
			calendar = [calendarStore calendarWithUID:[calendarNames objectAtIndex:i]];
			if(calendar){
				[foundCalendars addObject:calendar];
			}else{
				for(j = 0; j < [calendars count]; ++j){
					calendar = [calendars objectAtIndex:j];
					if([calendarNames containsObject:[calendar title]]){
						[foundCalendars addObject:calendar];
					}
				}
			}
		}
		
		if(![foundCalendars count]){
			returnValue.setIntValue(ERROR_CALENDAR_NOT_FOUND);
		}
		
		return foundCalendars;
	}
	
	NSArray * getCalendars(CalCalendarStore *calendarStore, ARRAY_TEXT &calendarNames){
		NSArray *calendars;
		NSMutableArray *calendarIds = [[NSMutableArray alloc]init];
		for(unsigned int i = 0; i < calendarNames.getSize(); ++i){
			CUTF16String calendar;
			calendarNames.copyUTF16StringAtIndex(&calendar, i);
			NSString *calendarId = [[NSString alloc]initWithCharacters:(const unichar *)calendar.c_str() length:calendar.length()];
			[calendarIds addObject:calendarId];
			[calendarId release];
		}
		C_LONGINT returnValueInternal;
		calendars = getCalendars(calendarStore, calendarIds, returnValueInternal);
		[calendarIds release];
		return calendars;
	}

	CalCalendar *getCalendar(CalCalendarStore *calendarStore, NSString *calendarName, C_LONGINT &returnValue){
		NSArray * calendars = getCalendars(calendarStore, [NSArray arrayWithObject:calendarName], returnValue);
		
		if([calendars count]){
			return [calendars objectAtIndex:0];
		}else{
			return nil;
		}
	}
	
	CalCalendarStore *getCalendarStore(C_LONGINT &returnValue){
		CalCalendarStore *calendarStore = nil;
		
		calendarStore = [CalCalendarStore defaultCalendarStore];
		
		if(!calendarStore)
		{
			returnValue.setIntValue(ERROR_ACCESS_DENIED);
		}
		
		return calendarStore;
	}
	
	void setEventProperty(CalEvent *event, NSString *key, NSString *value){
		NSArray *eventProperties = [NSArray arrayWithObjects:
																@"isAllDay", @"isDetached",
																@"location", @"occurrence",
																@"recurrence" ,@"startDate",
																@"calendar", @"hasAlarm",
																@"nextAlarmDate", @"dateStamp",
																@"notes", @"title",
																@"url", @"endDate", nil];
		if(event){
			NSUInteger pid = [eventProperties indexOfObject:key];
			switch (pid){
				case 0://isAllDay
					event.isAllDay = [value boolValue];
					break;
				case 1://isDetached (readonly)
					break;
				case 2://location
					event.location = value;
					break;
				case 3://occurrence (readonly)
					break;
				case 4://recurrence (dedicated command)
					break;
				case 5://startDate
					if([NSDate dateWithString:value]){
						event.startDate = [NSDate dateWithString:value];
					}
					break;
				case 6://calendar
				{
					C_LONGINT returnValue;
					CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
					if(defaultCalendarStore){
						CalCalendar *calendar = getCalendar(defaultCalendarStore, value, returnValue);
						if(calendar){
							event.calendar = calendar;
						}
					}
				}
					break;
				case 7://hasAlarm (readonly)
					break;
				case 8://nextAlarmDate (readonly)
					break;
				case 9://dateStamp (readonly)
					break;
				case 10://notes
					event.notes = value;
					break;
				case 11://title
					event.title = value;
					break;
				case 12://url
				{
					NSURL *url = [NSURL URLWithString:value];
					if(url){
						event.url = url;
					}
				}
					break;
				case 13://endDate
					if([NSDate dateWithString:value]){
						event.endDate = [NSDate dateWithString:value];
					}
					break;
				default:
					break;
			}
			
		}
	}

	NSDate *getDate(NSString *recordTime, C_LONGINT &returnValue){
		NSDate *date = nil;
		
		date = [NSDate dateWithString:recordTime];
		
		if(!date)
		{
			returnValue.setIntValue(ERROR_INVALID_DATE);
		}
		
		return date;
	}
	
	void getEventProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			
				CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:[NSDate dateWithString:recordSpecifier.date]];
				NSArray *eventProperties = [NSArray arrayWithObjects:
																		@"isAllDay", @"isDetached",
																		@"location", @"occurrence",
																		@"recurrence" ,@"startDate",
																		@"calendar", @"hasAlarm",
																		@"nextAlarmDate", @"dateStamp",
																		@"notes", @"title",
																		@"url", @"endDate",
																		@"attendees", nil];
				if(event){
					NSUInteger pid = [eventProperties indexOfObject:recordSpecifier.key];
					NSString *attendees = nil;
					switch (pid){
						case 0://isAllDay
							if(event.isAllDay)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 1://isDetached
							if(event.isDetached)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 2://location
							recordSpecifier.value.setUTF16String(event.location);
							recordSpecifier.isOK = true;
							break;
						case 3://occurrence
							recordSpecifier.value.setUTF16String([event.occurrence description]);
							recordSpecifier.isOK = true;
							break;
						case 4://recurrence
                        {
                            CalRecurrenceRule *recurrenceRule = event.recurrenceRule;
                            @autoreleasepool
                            {
                                NSNumber *recurrenceInterval = [NSNumber numberWithInt:0];
                                NSString *firstDayOfTheWeek = @"";
                                NSString *recurrenceType = @"";
                                NSArray *daysOfTheWeek = @[];
                                NSArray *daysOfTheMonth = @[];
                                NSArray *nthWeekDaysOfTheMonth = @[];
                                NSArray *monthsOfTheYear = @[];
                                NSDictionary *recurrenceEnd = @{};
                                
                                if(recurrenceRule)
                                {
                                    recurrenceInterval = [NSNumber numberWithInt:recurrenceRule.recurrenceInterval];
                                    firstDayOfTheWeek = [@[@"",
                                                           @"Sunday",
                                                           @"Monday",
                                                           @"Tuesday",
                                                           @"Wednesday",
                                                           @"Thursday",
                                                           @"Friday",
                                                           @"Saturday"] objectAtIndex:recurrenceRule.firstDayOfTheWeek];
                                    recurrenceType = [@[@"Daily",
                                                        @"Weekly",
                                                        @"Monthly",
                                                        @"Yearly"] objectAtIndex:recurrenceRule.recurrenceType];
                                    daysOfTheWeek = recurrenceRule.daysOfTheWeek ? recurrenceRule.daysOfTheWeek : @[];
                                    daysOfTheMonth = recurrenceRule.daysOfTheMonth ? recurrenceRule.daysOfTheMonth : @[];
                                    nthWeekDaysOfTheMonth = recurrenceRule.nthWeekDaysOfTheMonth ? recurrenceRule.nthWeekDaysOfTheMonth : @[];
                                    monthsOfTheYear = recurrenceRule.monthsOfTheYear ? recurrenceRule.monthsOfTheYear : @[];
                                    
                                    NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
                                    [GMT setDateFormat:DATE_FORMAT_ISO_GMT];
                                    [GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];

                                    recurrenceEnd = recurrenceRule.recurrenceEnd ? @{
                                                                                     @"occurrenceCount":[NSNumber numberWithInt:recurrenceRule.recurrenceEnd.occurrenceCount],
                                                                                     @"endDate":recurrenceRule.recurrenceEnd.endDate ? [GMT stringFromDate:recurrenceRule.recurrenceEnd.endDate] : @""
                                                                                     } : @{};
                                     [GMT release];
                                }
                                
                                NSDictionary *recurrence = @{
                                                             @"recurrenceInterval":recurrenceInterval,
                                                             @"firstDayOfTheWeek":firstDayOfTheWeek,
                                                             @"recurrenceType":recurrenceType,
                                                             @"recurrenceEnd":recurrenceEnd,
                                                             @"daysOfTheWeek":daysOfTheWeek,
                                                             @"daysOfTheMonth":daysOfTheMonth,
                                                             @"nthWeekDaysOfTheMonth":nthWeekDaysOfTheMonth,
                                                             @"monthsOfTheYear":monthsOfTheYear
                                                             };
                                if([NSJSONSerialization isValidJSONObject:recurrence])
                                {
                                    NSData *jsonData = [NSJSONSerialization
                                                        dataWithJSONObject:recurrence
                                                        options:0
                                                        error:NULL];
                                    if(jsonData)
                                    {
                                        NSString *json = [NSString stringWithCString:(const char *)[jsonData bytes] encoding:NSUTF8StringEncoding];
                                        recordSpecifier.value.setUTF16String(json);
                                        recordSpecifier.isOK = true;
                                    }
                                }
                            }
                        }
							break;
						case 5://startDate
							recordSpecifier.value.setUTF16String([event.startDate description]);
							recordSpecifier.isOK = true;
							break;
						case 6://calendar
							recordSpecifier.value.setUTF16String([event.calendar uid]);
							recordSpecifier.isOK = true;
							break;
						case 7://hasAlarm
							if(event.hasAlarm)
							{
								recordSpecifier.value.setUTF16String(@"YES");
							}else{
								recordSpecifier.value.setUTF16String(@"NO");
							}
							recordSpecifier.isOK = true;
							break;
						case 8://nextAlarmDate
							recordSpecifier.value.setUTF16String([event.nextAlarmDate description]);
							recordSpecifier.isOK = true;
							break;
						case 9://dateStamp
							recordSpecifier.value.setUTF16String([event.dateStamp description]);
							recordSpecifier.isOK = true;
							break;
						case 10://notes
							recordSpecifier.value.setUTF16String(event.notes);
							recordSpecifier.isOK = true;
							break;
						case 11://title
							recordSpecifier.value.setUTF16String(event.title);
							recordSpecifier.isOK = true;
							break;
						case 12://url
							recordSpecifier.value.setUTF16String([event.url absoluteString]);
							recordSpecifier.isOK = true;
							break;
						case 13://endDate
							recordSpecifier.value.setUTF16String([event.endDate description]);
							recordSpecifier.isOK = true;
							break;
						case 14://attendees
							attendees = copyAttendeesDictionary(event.attendees);
							recordSpecifier.value.setUTF16String(attendees);
							[attendees release];
							recordSpecifier.isOK = true;
						default:
							break;
					}		
				}
				recordSpecifier.isDone = true;
		}
	}
	
	int newProcess(void* procPtr, int stackSize, NSString *name){
		C_TEXT t;
		t.setUTF16String(name);
		
		return PA_NewProcess(procPtr, stackSize, (PA_Unichar *)t.getUTF16StringPtr());
	}
	
	NSColor *getColorFromString(NSString *dictionary){
		NSColor *color = NULL;
		if(dictionary)
		{
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, (CFDataRef)[dictionary dataUsingEncoding:NSUTF8StringEncoding], kCFPropertyListImmutable, NULL);
			
			if(dictionaryPropertyList)
			{
				if(CFGetTypeID(dictionaryPropertyList) == CFDictionaryGetTypeID())
				{
					NSDictionary *dictionary = (NSDictionary *)dictionaryPropertyList;
					
					float redComponent = [[dictionary objectForKey:@"redComponent"]floatValue];
					float greenComponent = [[dictionary objectForKey:@"greenComponent"]floatValue];
					float blueComponent = [[dictionary objectForKey:@"blueComponent"]floatValue];
					float alphaComponent = [[dictionary objectForKey:@"alphaComponent"]floatValue];
					
					color = [NSColor colorWithDeviceRed:redComponent green:greenComponent blue:blueComponent alpha:alphaComponent];
				}
				CFRelease(dictionaryPropertyList);
			}
		}
		
		return color;
		
	}
	
	void getDateTimeOffsetFromString(NSString *dateString, PA_Date *date, int *time, int *offset){
		if(dateString)
		{
			NSDate *nsd = [NSDate dateWithString:dateString];
			if(nsd)
			{
				NSString *description = [nsd description];
				
				if([description length] == 25)
				{
					date->fYear = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
					date->fMonth = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
					date->fDay = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
					int hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
					int minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
					int second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
					*time = second + (minute * 60) + (hour * 3600);
					NSTimeZone *zone = [NSTimeZone timeZoneWithName:[@"GMT" stringByAppendingString:[dateString substringWithRange:NSMakeRange(20,5)]]];
					if(zone) *offset = [zone secondsFromGMTForDate:nsd];
				}
			}
		}	
	}
	
	NSString *copyDateTimeZoneString(PA_Date *date, int time, NSString *name){
		NSString *description = NULL;
		
		if(name)
		{
			NSTimeZone *zone = [NSTimeZone timeZoneWithName:name];
			if(!zone) zone = [NSTimeZone localTimeZone];
			
			CFGregorianDate gregDate;
			gregDate.year = date->fYear;
			gregDate.month = date->fMonth;
			gregDate.day = date->fDay;
			gregDate.hour = 0;
			gregDate.minute = 0;
			gregDate.second = 0;
			
			CFGregorianUnits offset;
			offset.years = 0;
			offset.months = 0;
			offset.days = 0;
			offset.minutes = 0;
			offset.hours = 0;
			offset.seconds = time;
			
			if( CFGregorianDateIsValid( gregDate, kCFGregorianUnitsYears+kCFGregorianUnitsMonths+kCFGregorianUnitsDays))
			{
				CFAbsoluteTime at = CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)zone);
				CFAbsoluteTime seconds = CFAbsoluteTimeAddGregorianUnits(at, (CFTimeZoneRef)zone, offset);
				NSDate *nsd = (NSDate *)CFDateCreate(kCFAllocatorDefault, seconds);
				description = [[NSString alloc]initWithString:[nsd description]];
				[nsd release];
			}
			
		}
		
		if(description)
		{
			return description;
		}else{
			return @"";	
		}
		
	}
	
	NSString *copyColorString(NSColor *color){
		NSString *colorData = NULL;
		
		if(color)
		{
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			
			[dictionary setObject:[NSNumber numberWithFloat:[color redComponent]] forKey:@"redComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color greenComponent]] forKey:@"greenComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color blueComponent]] forKey:@"blueComponent"];
			[dictionary setObject:[NSNumber numberWithFloat:[color alphaComponent]] forKey:@"alphaComponent"];
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			colorData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			[dictionary release];
		}else{colorData = @"";}
		
		return colorData;
		
	}
	
	NSColor *getColorIndex(int index){
		float redComponent;
		float greenComponent;
		float blueComponent;
		float alphaComponent = 1;
		
		switch(index){
			case 1 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 2 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 3 :
				redComponent = 0;
				greenComponent = 0.4;
				blueComponent = 1;
				break;
			case 4 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.9333333333333333481;
				break;
			case 5 :
				redComponent = 0.6;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 6 :
				redComponent = 0.6;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 7 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 8 :
				redComponent = 1;
				greenComponent = 0.6;
				blueComponent = 0;
				break;
			case 9 :
				redComponent = 0;
				greenComponent = 0.7333333333333332815;
				blueComponent = 0;
				break;
			case 10 :
				redComponent = 0;
				greenComponent = 0.6;
				blueComponent = 0;
				break;
			case 11 :
				redComponent = 0;
				greenComponent = 0.2;
				blueComponent = 0.4;
				break;
			case 12 :
				redComponent = 0.266666666666666663;
				greenComponent = 0.266666666666666663;
				blueComponent = 0.266666666666666663;
				break;
			case 13 :
				redComponent = 0.8666666666666666963;
				greenComponent = 0.8666666666666666963;
				blueComponent = 0.8666666666666666963;
				break;
			case 14 :
				redComponent = 0;
				greenComponent = 0.4;
				blueComponent = 0.6;
				break;
			case 15 :
				redComponent = 0.6666666666666666297;
				greenComponent = 0.6666666666666666297;
				blueComponent = 0.6666666666666666297;
				break;
			case 16 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0;
				break;
			case 17 :
				redComponent = 0.3686274509804;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 18 :
				redComponent = 0.3372549019607843368;
				greenComponent = 0.01568627450980392135;
				blueComponent = 1;
				break;
			case 19 :
				redComponent = 0.2823529411764705843;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 20 :
				redComponent = 0.2941176470588235392;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 21 :
				redComponent = 0.1960784313725490169;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 22 :
				redComponent = 0.152941176470588247;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 23 :
				redComponent = 0.1098039215686274495;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 24 :
				redComponent = 0.06666666666666666574;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 25 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 26 :
				redComponent = 0;
				greenComponent = 0.01568627450980392135;
				blueComponent = 1;
				break;
			case 27 :
				redComponent = 0;
				greenComponent = 0.05882352941176470507;
				blueComponent = 1;
				break;
			case 28 :
				redComponent = 0;
				greenComponent = 0.1019607843137254888;
				blueComponent = 1;
				break;
			case 29 :
				redComponent = 0;
				greenComponent = 0.1450980392156862864;
				blueComponent = 1;
				break;
			case 30 :
				redComponent = 0;
				greenComponent = 0.1882352941176470562;
				blueComponent = 1;
				break;
			case 31 :
				redComponent = 0;
				greenComponent = 0.2313725490196;
				blueComponent = 1;
				break;
			case 32 :
				redComponent = 0;
				greenComponent = 0.2745098039215686514;
				blueComponent = 1;
				break;
			case 33 :
				redComponent = 0;
				greenComponent = 0.3019607843137254721;
				blueComponent = 1;
				break;
			case 34 :
				redComponent = 0;
				greenComponent = 0.3294117647058823484;
				blueComponent = 1;
				break;
			case 35 :
				redComponent = 0;
				greenComponent = 0.3568627450980392246;
				blueComponent = 1;
				break;
			case 36 :
				redComponent = 0;
				greenComponent = 0.3843137254902;
				blueComponent = 1;
				break;
			case 37 :
				redComponent = 0;
				greenComponent = 0.4117647058823529216;
				blueComponent = 1;
				break;
			case 38 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.4470588235294117863;
				blueComponent = 1;
				break;
			case 39 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.4862745098039215619;
				blueComponent = 1;
				break;
			case 40 :
				redComponent = 0.007843137254902;
				greenComponent = 0.5098039215686274161;
				blueComponent = 1;
				break;
			case 41 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0.5411764705882352589;
				blueComponent = 1;
				break;
			case 42 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.5725490196078431016;
				blueComponent = 1;
				break;
			case 43 :
				redComponent = 0.007843137254902;
				greenComponent = 0.6;
				blueComponent = 1;
				break;
			case 44 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 45 :
				redComponent = 0;
				greenComponent = 0.6235294117647;
				blueComponent = 1;
				break;
			case 46 :
				redComponent = 0.0627450980392156854;
				greenComponent = 0.6823529411764706065;
				blueComponent = 1;
				break;
			case 47 :
				redComponent = 0.02745098039215686236;
				greenComponent = 0.6941176470588235059;
				blueComponent = 1;
				break;
			case 48 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.7215686274509803821;
				blueComponent = 1;
				break;
			case 49 :
				redComponent = 0;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 50 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.7803921568627451011;
				blueComponent = 1;
				break;
			case 51 :
				redComponent = 0;
				greenComponent = 0.8078431372549;
				blueComponent = 1;
				break;
			case 52 :
				redComponent = 0;
				greenComponent = 0.8431372549019607865;
				blueComponent = 1;
				break;
			case 53 :
				redComponent = 0.01176470588235294101;
				greenComponent = 0.8745098039215686292;
				blueComponent = 1;
				break;
			case 54 :
				redComponent = 0.01960784313725490169;
				greenComponent = 0.9019607843137255054;
				blueComponent = 1;
				break;
			case 55 :
				redComponent = 0.03921568627451;
				greenComponent = 0.9372549019607843146;
				blueComponent = 1;
				break;
			case 56 :
				redComponent = 0.01568627450980392135;
				greenComponent = 0.9647058823529411908;
				blueComponent = 1;
				break;
			case 57 :
				redComponent = 0.02352941176470588203;
				greenComponent = 0.9921568627451;
				blueComponent = 1;
				break;
			case 58 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9764705882353;
				break;
			case 59 :
				redComponent = 0.01568627450980392135;
				greenComponent = 1;
				blueComponent = 0.949019607843137214;
				break;
			case 60 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9215686274509803377;
				break;
			case 61 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.8862745098039215286;
				break;
			case 62 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.8274509803921568096;
				break;
			case 63 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.7921568627451;
				break;
			case 64 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.7647058823529411242;
				break;
			case 65 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.737254901960784359;
				break;
			case 66 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.6509803921568627638;
				break;
			case 67 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.5647058823529411686;
				break;
			case 68 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.478431372549019629;
				break;
			case 69 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.3921568627451;
				break;
			case 70 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.3098039215686274606;
				break;
			case 71 :
				redComponent = 0.01176470588235294101;
				greenComponent = 1;
				blueComponent = 0.2352941176470588203;
				break;
			case 72 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.04705882352941176405;
				break;
			case 73 :
				redComponent = 0.04705882352941176405;
				greenComponent = 1;
				blueComponent = 0.01176470588235294101;
				break;
			case 74 :
				redComponent = 0.1372549019607843257;
				greenComponent = 1;
				blueComponent = 0.01568627450980392135;
				break;
			case 75 :
				redComponent = 0.2078431372549;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 76 :
				redComponent = 0.2941176470588235392;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 77 :
				redComponent = 0.3764705882353;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 78 :
				redComponent = 0.4627450980392157076;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 79 :
				redComponent = 0.5490196078431373028;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 80 :
				redComponent = 0.6549019607843137303;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 81 :
				redComponent = 0.6549019607843137303;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 82 :
				redComponent = 0.6941176470588235059;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 83 :
				redComponent = 0.7333333333333332815;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 84 :
				redComponent = 0.7725490196078431682;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 85 :
				redComponent = 0.8156862745098;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 86 :
				redComponent = 0.8549019607843136859;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 87 :
				redComponent = 0.8941176470588235725;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 88 :
				redComponent = 0.9333333333333333481;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 89 :
				redComponent = 0.9725490196078431238;
				greenComponent = 1;
				blueComponent = 0;
				break;
			case 90 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0;
				break;
			case 91 :
				redComponent = 1;
				greenComponent = 0.9529411764705881804;
				blueComponent = 0;
				break;
			case 92 :
				redComponent = 1;
				greenComponent = 0.9137254901960784048;
				blueComponent = 0;
				break;
			case 93 :
				redComponent = 1;
				greenComponent = 0.8784313725490195957;
				blueComponent = 0;
				break;
			case 94 :
				redComponent = 1;
				greenComponent = 0.8352941176470588536;
				blueComponent = 0;
				break;
			case 95 :
				redComponent = 1;
				greenComponent = 0.7960784313725489669;
				blueComponent = 0;
				break;
			case 96 :
				redComponent = 1;
				greenComponent = 0.7568627450980391913;
				blueComponent = 0;
				break;
			case 97 :
				redComponent = 1;
				greenComponent = 0.7058823529411765163;
				blueComponent = 0;
				break;
			case 98 :
				redComponent = 1;
				greenComponent = 0.6313725490196;
				blueComponent = 0;
				break;
			case 99 :
				redComponent = 1;
				greenComponent = 0.5568627450980392357;
				blueComponent = 0;
				break;
			case 100 :
				redComponent = 1;
				greenComponent = 0.4862745098039215619;
				blueComponent = 0;
				break;
			case 101 :
				redComponent = 1;
				greenComponent = 0.4117647058823529216;
				blueComponent = 0;
				break;
			case 102 :
				redComponent = 1;
				greenComponent = 0.3372549019607843368;
				blueComponent = 0;
				break;
			case 103 :
				redComponent = 1;
				greenComponent = 0.2627450980392156965;
				blueComponent = 0;
				break;
			case 104 :
				redComponent = 1;
				greenComponent = 0.1568627450980392135;
				blueComponent = 0.003921568627451;
				break;
			case 105 :
				redComponent = 1;
				greenComponent = 0.1176470588235294101;
				blueComponent = 0;
				break;
			case 106 :
				redComponent = 1;
				greenComponent = 0.04313725490196;
				blueComponent = 0;
				break;
			case 107 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.02745098039215686236;
				break;
			case 108 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.09803921568627450844;
				break;
			case 109 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.1725490196078431349;
				break;
			case 110 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.2470588235294117752;
				break;
			case 111 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.3215686274509804154;
				break;
			case 112 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.3960784313725490002;
				break;
			case 113 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.4705882352941176405;
				break;
			case 114 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.5450980392156862253;
				break;
			case 115 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.6196078431372549211;
				break;
			case 116 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.6941176470588235059;
				break;
			case 117 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.7686274509804;
				break;
			case 118 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.8431372549019607865;
				break;
			case 119 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.9176470588235293713;
				break;
			case 120 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 0.9921568627451;
				break;
			case 121 :
				redComponent = 0.9372549019607843146;
				greenComponent = 0.01176470588235294101;
				blueComponent = 1;
				break;
			case 122 :
				redComponent = 0.8627450980392157298;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 123 :
				redComponent = 0.788235294117647034;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 124 :
				redComponent = 0.7137254901960784492;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 125 :
				redComponent = 0.6392156862745;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 126 :
				redComponent = 0.5647058823529411686;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 127 :
				redComponent = 0.4901960784313725283;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 128 :
				redComponent = 0.4156862745098;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 129 :
				redComponent = 0.8784313725490195957;
				greenComponent = 0.8784313725490195957;
				blueComponent = 1;
				break;
			case 130 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 131 :
				redComponent = 0.627450980392156854;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 132 :
				redComponent = 0.4980392156862745168;
				greenComponent = 0.4980392156862745168;
				blueComponent = 1;
				break;
			case 133 :
				redComponent = 0.372549019607843146;
				greenComponent = 0.372549019607843146;
				blueComponent = 1;
				break;
			case 134 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.2509803921568627416;
				blueComponent = 1;
				break;
			case 135 :
				redComponent = 0.1254901960784313708;
				greenComponent = 0.1254901960784313708;
				blueComponent = 1;
				break;
			case 136 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 137 :
				redComponent = 0;
				greenComponent = 0.05882352941176470507;
				blueComponent = 0.9254901960784314152;
				break;
			case 138 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.847058823529411753;
				break;
			case 139 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.8117647058823529438;
				break;
			case 140 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.6901960784313725394;
				break;
			case 141 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.6117647058823529882;
				break;
			case 142 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.5333333333333333259;
				break;
			case 143 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.4549019607843137192;
				break;
			case 144 :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0.3764705882353;
				break;
			case 145 :
				redComponent = 0.8745098039215686292;
				greenComponent = 0.9411764705882352811;
				blueComponent = 1;
				break;
			case 146 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.8784313725490195957;
				blueComponent = 1;
				break;
			case 147 :
				redComponent = 0.627450980392156854;
				greenComponent = 0.8117647058823529438;
				blueComponent = 1;
				break;
			case 148 :
				redComponent = 0.4980392156862745168;
				greenComponent = 0.7450980392156862919;
				blueComponent = 1;
				break;
			case 149 :
				redComponent = 0.372549019607843146;
				greenComponent = 0.6901960784313725394;
				blueComponent = 1;
				break;
			case 150 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.6313725490196;
				blueComponent = 1;
				break;
			case 151 :
				redComponent = 0.1254901960784313708;
				greenComponent = 0.5686274509804;
				blueComponent = 1;
				break;
			case 152 :
				redComponent = 0;
				greenComponent = 0.5058823529411764497;
				blueComponent = 1;
				break;
			case 153 :
				redComponent = 0;
				greenComponent = 0.4666666666666666741;
				blueComponent = 0.9254901960784314152;
				break;
			case 154 :
				redComponent = 0;
				greenComponent = 0.4274509803921568429;
				blueComponent = 0.847058823529411753;
				break;
			case 155 :
				redComponent = 0;
				greenComponent = 0.3882352941176470673;
				blueComponent = 0.7686274509804;
				break;
			case 156 :
				redComponent = 0;
				greenComponent = 0.3490196078431372362;
				blueComponent = 0.6901960784313725394;
				break;
			case 157 :
				redComponent = 0;
				greenComponent = 0.3215686274509804154;
				blueComponent = 0.6117647058823529882;
				break;
			case 158 :
				redComponent = 0;
				greenComponent = 0.2705882352941176294;
				blueComponent = 0.5333333333333333259;
				break;
			case 159 :
				redComponent = 0;
				greenComponent = 0.2313725490196;
				blueComponent = 0.4549019607843137192;
				break;
			case 160 :
				redComponent = 0;
				greenComponent = 0.1882352941176470562;
				blueComponent = 0.3764705882353;
				break;
			case 161 :
				redComponent = 0.8745098039215686292;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 162 :
				redComponent = 0.7529411764705882248;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 163 :
				redComponent = 0.627450980392156854;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 164 :
				redComponent = 0.4980392156862745168;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 165 :
				redComponent = 0.372549019607843146;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 166 :
				redComponent = 0.2509803921568627416;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 167 :
				redComponent = 0.1254901960784313708;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 168 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.9960784313725490335;
				break;
			case 169 :
				redComponent = 0;
				greenComponent = 0.9254901960784314152;
				blueComponent = 0.9176470588235293713;
				break;
			case 170 :
				redComponent = 0;
				greenComponent = 0.8431372549019607865;
				blueComponent = 0.8392156862745;
				break;
			case 171 :
				redComponent = 0;
				greenComponent = 0.7647058823529411242;
				blueComponent = 0.7607843137255;
				break;
			case 172 :
				redComponent = 0;
				greenComponent = 0.686274509803921573;
				blueComponent = 0.6823529411764706065;
				break;
			case 173 :
				redComponent = 0;
				greenComponent = 0.6235294117647;
				blueComponent = 0.6196078431372549211;
				break;
			case 174 :
				redComponent = 0;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.5294117647058823595;
				break;
			case 175 :
				redComponent = 0;
				greenComponent = 0.4549019607843137192;
				blueComponent = 0.4509803921568627527;
				break;
			case 176 :
				redComponent = 0;
				greenComponent = 0.3764705882353;
				blueComponent = 0.372549019607843146;
				break;
			case 177 :
				redComponent = 0.8745098039215686292;
				greenComponent = 1;
				blueComponent = 0.8862745098039215286;
				break;
			case 178 :
				redComponent = 0.7529411764705882248;
				greenComponent = 1;
				blueComponent = 0.7725490196078431682;
				break;
			case 179 :
				redComponent = 0.627450980392156854;
				greenComponent = 1;
				blueComponent = 0.6549019607843137303;
				break;
			case 180 :
				redComponent = 0.4980392156862745168;
				greenComponent = 1;
				blueComponent = 0.5372549019607842924;
				break;
			case 181 :
				redComponent = 0.372549019607843146;
				greenComponent = 1;
				blueComponent = 0.4235294117647;
				break;
			case 182 :
				redComponent = 0.2509803921568627416;
				greenComponent = 1;
				blueComponent = 0.3098039215686274606;
				break;
			case 183 :
				redComponent = 0.1254901960784313708;
				greenComponent = 1;
				blueComponent = 0.1921568627451;
				break;
			case 184 :
				redComponent = 0;
				greenComponent = 1;
				blueComponent = 0.07450980392156862642;
				break;
			case 185 :
				redComponent = 0;
				greenComponent = 0.9254901960784314152;
				blueComponent = 0.07058823529411764608;
				break;
			case 186 :
				redComponent = 0;
				greenComponent = 0.847058823529411753;
				blueComponent = 0.0627450980392156854;
				break;
			case 187 :
				redComponent = 0;
				greenComponent = 0.7686274509804;
				blueComponent = 0.05882352941176470507;
				break;
			case 188 :
				redComponent = 0;
				greenComponent = 0.6901960784313725394;
				blueComponent = 0.05098039215686274439;
				break;
			case 189 :
				redComponent = 0;
				greenComponent = 0.6117647058823529882;
				blueComponent = 0.04705882352941176405;
				break;
			case 190 :
				redComponent = 0;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.03921568627451;
				break;
			case 191 :
				redComponent = 0;
				greenComponent = 0.4549019607843137192;
				blueComponent = 0.03529411764705882304;
				break;
			case 192 :
				redComponent = 0;
				greenComponent = 0.3764705882353;
				blueComponent = 0.02745098039215686236;
				break;
			case 193 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.8745098039215686292;
				break;
			case 194 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.7529411764705882248;
				break;
			case 195 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 0.627450980392156854;
				break;
			case 196 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.4980392156862745168;
				break;
			case 197 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.372549019607843146;
				break;
			case 198 :
				redComponent = 1;
				greenComponent = 0.9960784313725490335;
				blueComponent = 0.2509803921568627416;
				break;
			case 199 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0.1254901960784313708;
				break;
			case 200 :
				redComponent = 1;
				greenComponent = 0.9921568627451;
				blueComponent = 0;
				break;
			case 201 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0.9137254901960784048;
				blueComponent = 0;
				break;
			case 202 :
				redComponent = 0.847058823529411753;
				greenComponent = 0.8392156862745;
				blueComponent = 0;
				break;
			case 203 :
				redComponent = 0.7686274509804;
				greenComponent = 0.7607843137255;
				blueComponent = 0;
				break;
			case 204 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0.6823529411764706065;
				blueComponent = 0;
				break;
			case 205 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0.6078431372549;
				blueComponent = 0;
				break;
			case 206 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.5294117647058823595;
				blueComponent = 0;
				break;
			case 207 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0.4509803921568627527;
				blueComponent = 0;
				break;
			case 208 :
				redComponent = 0.3764705882353;
				greenComponent = 0.372549019607843146;
				blueComponent = 0;
				break;
			case 209 :
				redComponent = 1;
				greenComponent = 0.8941176470588235725;
				blueComponent = 0.8745098039215686292;
				break;
			case 210 :
				redComponent = 1;
				greenComponent = 0.7921568627451;
				blueComponent = 0.7529411764705882248;
				break;
			case 211 :
				redComponent = 1;
				greenComponent = 0.686274509803921573;
				blueComponent = 0.627450980392156854;
				break;
			case 212 :
				redComponent = 1;
				greenComponent = 0.5764705882353;
				blueComponent = 0.4980392156862745168;
				break;
			case 213 :
				redComponent = 1;
				greenComponent = 0.4705882352941176405;
				blueComponent = 0.372549019607843146;
				break;
			case 214 :
				redComponent = 1;
				greenComponent = 0.3686274509804;
				blueComponent = 0.2509803921568627416;
				break;
			case 215 :
				redComponent = 1;
				greenComponent = 0.25882352941176473;
				blueComponent = 0.1254901960784313708;
				break;
			case 216 :
				redComponent = 1;
				greenComponent = 0.152941176470588247;
				blueComponent = 0;
				break;
			case 217 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0.1411764705882352922;
				blueComponent = 0;
				break;
			case 218 :
				redComponent = 0.847058823529411753;
				greenComponent = 0.129411764705882365;
				blueComponent = 0;
				break;
			case 219 :
				redComponent = 0.8117647058823529438;
				greenComponent = 0.1254901960784313708;
				blueComponent = 0;
				break;
			case 220 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0.1058823529411764691;
				blueComponent = 0;
				break;
			case 221 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0.09411764705882352811;
				blueComponent = 0;
				break;
			case 222 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.08235294117647;
				blueComponent = 0;
				break;
			case 223 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0.07058823529411764608;
				blueComponent = 0;
				break;
			case 224 :
				redComponent = 0.3764705882353;
				greenComponent = 0.05490196078431372473;
				blueComponent = 0;
				break;
			case 225 :
				redComponent = 1;
				greenComponent = 0.8745098039215686292;
				blueComponent = 1;
				break;
			case 226 :
				redComponent = 1;
				greenComponent = 0.7529411764705882248;
				blueComponent = 1;
				break;
			case 227 :
				redComponent = 1;
				greenComponent = 0.627450980392156854;
				blueComponent = 1;
				break;
			case 228 :
				redComponent = 1;
				greenComponent = 0.4980392156862745168;
				blueComponent = 1;
				break;
			case 229 :
				redComponent = 1;
				greenComponent = 0.372549019607843146;
				blueComponent = 1;
				break;
			case 230 :
				redComponent = 1;
				greenComponent = 0.2509803921568627416;
				blueComponent = 1;
				break;
			case 231 :
				redComponent = 1;
				greenComponent = 0.1254901960784313708;
				blueComponent = 1;
				break;
			case 232 :
				redComponent = 1;
				greenComponent = 0;
				blueComponent = 1;
				break;
			case 233 :
				redComponent = 0.9254901960784314152;
				greenComponent = 0;
				blueComponent = 0.9215686274509803377;
				break;
			case 234 :
				redComponent = 0.847058823529411753;
				greenComponent = 0;
				blueComponent = 0.8431372549019607865;
				break;
			case 235 :
				redComponent = 0.8117647058823529438;
				greenComponent = 0;
				blueComponent = 0.8117647058823529438;
				break;
			case 236 :
				redComponent = 0.6901960784313725394;
				greenComponent = 0;
				blueComponent = 0.6901960784313725394;
				break;
			case 237 :
				redComponent = 0.6117647058823529882;
				greenComponent = 0;
				blueComponent = 0.6117647058823529882;
				break;
			case 238 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0;
				blueComponent = 0.5333333333333333259;
				break;
			case 239 :
				redComponent = 0.4549019607843137192;
				greenComponent = 0;
				blueComponent = 0.4549019607843137192;
				break;
			case 240 :
				redComponent = 0.3764705882353;
				greenComponent = 0;
				blueComponent = 0.3764705882353;
				break;
			case 241 :
				redComponent = 1;
				greenComponent = 1;
				blueComponent = 1;
				break;
			case 242 :
				redComponent = 0.9333333333333333481;
				greenComponent = 0.9333333333333333481;
				blueComponent = 0.9333333333333333481;
				break;
			case 243 :
				redComponent = 0.8666666666666666963;
				greenComponent = 0.8666666666666666963;
				blueComponent = 0.8666666666666666963;
				break;
			case 244 :
				redComponent = 0.8;
				greenComponent = 0.8;
				blueComponent = 0.8;
				break;
			case 245 :
				redComponent = 0.7529411764705882248;
				greenComponent = 0.7529411764705882248;
				blueComponent = 0.7529411764705882248;
				break;
			case 246 :
				redComponent = 0.6666666666666666297;
				greenComponent = 0.6666666666666666297;
				blueComponent = 0.6666666666666666297;
				break;
			case 247 :
				redComponent = 0.6;
				greenComponent = 0.6;
				blueComponent = 0.6;
				break;
			case 248 :
				redComponent = 0.5333333333333333259;
				greenComponent = 0.5333333333333333259;
				blueComponent = 0.5333333333333333259;
				break;
			case 249 :
				redComponent = 0.4666666666666666741;
				greenComponent = 0.4666666666666666741;
				blueComponent = 0.4666666666666666741;
				break;
			case 250 :
				redComponent = 0.4;
				greenComponent = 0.4;
				blueComponent = 0.4;
				break;
			case 251 :
				redComponent = 0.3333333333333333148;
				greenComponent = 0.3333333333333333148;
				blueComponent = 0.3333333333333333148;
				break;
			case 252 :
				redComponent = 0.2509803921568627416;
				greenComponent = 0.2509803921568627416;
				blueComponent = 0.2509803921568627416;
				break;
			case 253 :
				redComponent = 0.2;
				greenComponent = 0.2;
				blueComponent = 0.2;
				break;
			case 254 :
				redComponent = 0.1333333333333333315;
				greenComponent = 0.1333333333333333315;
				blueComponent = 0.1333333333333333315;
				break;
			case 255 :
				redComponent = 0.06666666666666666574;
				greenComponent = 0.06666666666666666574;
				blueComponent = 0.06666666666666666574;
				break;
			default :
				redComponent = 0;
				greenComponent = 0;
				blueComponent = 0;
				break;
		}	
		
		//RGB -> BGR
		return [NSColor colorWithDeviceRed:blueComponent green:greenComponent blue:redComponent alpha:alphaComponent];
	}
	
	CalAlarm *getAlarmFromString(NSString *dictionary){
		CalAlarm *alarm = nil;
		NSDate *d = nil;
		NSURL *u = nil;
		
		if(dictionary){
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, (CFDataRef)[dictionary dataUsingEncoding:NSUTF8StringEncoding], kCFPropertyListImmutable, NULL);
			
			if(dictionaryPropertyList){
				
				if(CFGetTypeID(dictionaryPropertyList) == CFDictionaryGetTypeID()){
					
					alarm = [CalAlarm alarm];
					NSDictionary *dictionary = (NSDictionary *)dictionaryPropertyList;
					
					if([dictionary objectForKey:@"action"])
						alarm.action = (NSString *)[dictionary objectForKey:@"action"];
					
					if([dictionary objectForKey:@"absoluteTrigger"]){
						d = [NSDate dateWithString:(NSString *)[dictionary objectForKey:@"absoluteTrigger"]];
						if(d)alarm.absoluteTrigger = d;
					}
					
					if([dictionary objectForKey:@"emailAddress"])
						alarm.emailAddress = (NSString *)[dictionary objectForKey:@"emailAddress"];
					
					if([dictionary objectForKey:@"relativeTrigger"])
						alarm.relativeTrigger = [[dictionary objectForKey:@"relativeTrigger"]doubleValue];
					
					if([dictionary objectForKey:@"sound"])
						alarm.sound = (NSString *)[dictionary objectForKey:@"sound"];
					
					if([dictionary objectForKey:@"url"]){
						u = [NSURL URLWithString:(NSString *)[dictionary objectForKey:@"url"]];
						if(u)if([u isFileURL])alarm.url = u;
					}
				}
				CFRelease(dictionaryPropertyList);
			}
		}
		
		return alarm;
		
	}
	
	NSString *copyAlarmString(CalAlarm *alarm){
		NSString *alarmData = nil;
		
		if(alarm)
		{
			NSMutableDictionary *dictionary = [[NSMutableDictionary alloc]init];
			
			if(alarm.action)
			{
				[dictionary setObject:alarm.action forKey:@"action"];
			}else{
				[dictionary setObject:@"" forKey:@"action"];
			}
			if(alarm.absoluteTrigger)
			{
				[dictionary setObject:[alarm.absoluteTrigger description] forKey:@"absoluteTrigger"];
			}else{
				[dictionary setObject:@"" forKey:@"absoluteTrigger"];
			}
			if(alarm.emailAddress)
			{
				[dictionary setObject:alarm.emailAddress forKey:@"emailAddress"];
			}else{
				[dictionary setObject:@"" forKey:@"emailAddress"];
			}
			if(alarm.relativeTrigger)
			{
				[dictionary setObject:[NSNumber numberWithDouble:alarm.relativeTrigger] forKey:@"relativeTrigger"];
			}else{
				[dictionary setObject:@"" forKey:@"relativeTrigger"];
			}
			if(alarm.sound)
			{
				[dictionary setObject:alarm.sound forKey:@"sound"];
			}else{
				[dictionary setObject:@"" forKey:@"sound"];
			}
			if(alarm.url)
			{
				[dictionary setObject:[alarm.url absoluteString] forKey:@"url"];
			}else{
				[dictionary setObject:@"" forKey:@"url"];
			}
			
			CFPropertyListRef dictionaryPropertyList = CFPropertyListCreateDeepCopy(kCFAllocatorDefault, (CFDictionaryRef)dictionary, kCFPropertyListImmutable);
			NSData *dictionaryData = (NSData *)CFPropertyListCreateXMLData(kCFAllocatorDefault, dictionaryPropertyList);
			
			alarmData = [[NSString alloc]initWithData:dictionaryData encoding:NSUTF8StringEncoding];
			
			[dictionaryData release];
			CFRelease(dictionaryPropertyList);
			[dictionary release];
			
		}else{alarmData = @"";}
		
		return alarmData;	
		
	}
	
	void getCalendarProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalCalendar *calendar = getCalendar(defaultCalendarStore, recordSpecifier.uid, returnValue);
			if(calendar){
				NSArray *calendarProperties = [NSArray arrayWithObjects:
																			 @"color", @"isEditable", @"notes", @"title", @"type", nil];
				
				NSUInteger pid = [calendarProperties indexOfObject:recordSpecifier.key];
				NSString *colorString;
				
				switch (pid){
					case 0://color
						colorString = copyColorString(calendar.color);
						recordSpecifier.value.setUTF16String(colorString);
						[colorString release];
						recordSpecifier.isOK = true;
						break;
					case 1://isEditable
						if(calendar.isEditable)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 2://notes
						recordSpecifier.value.setUTF16String(calendar.notes);
						recordSpecifier.isOK = true;
						break;
					case 3://title
						recordSpecifier.value.setUTF16String(calendar.title);
						recordSpecifier.isOK = true;
						break;
					case 4://type
						recordSpecifier.value.setUTF16String(calendar.type);
						recordSpecifier.isOK = true;
						break;
					default:
						break;
				}
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getTaskProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
			NSArray *taskProperties = [NSArray arrayWithObjects:
																 @"dueDate", @"isCompleted",
																 @"priority", @"completedDate" ,
																 @"hasAlarm", @"nextAlarmDate",
																 @"calendar", @"dateStamp",
																 @"notes", @"title",
																 @"url", nil];
			
			if(task){
				NSUInteger pid = [taskProperties indexOfObject:recordSpecifier.key];
				switch (pid){
					case 0://dueDate
						recordSpecifier.value.setUTF16String([task.dueDate description]);
						recordSpecifier.isOK = true;
						break;
					case 1://isCompleted
						if(task.isCompleted)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 2://priority
						if(task.priority){
							recordSpecifier.value.setUTF16String([[NSNumber numberWithInt:task.priority]stringValue]);
						}else{
							recordSpecifier.value.setUTF16String(@"0");
						}
						recordSpecifier.isOK = true;
						break;
					case 3://completedDate
						recordSpecifier.value.setUTF16String([task.completedDate description]);
						recordSpecifier.isOK = true;
						break;
					case 4://hasAlarm
						if(task.hasAlarm)
						{
							recordSpecifier.value.setUTF16String(@"YES");
						}else{
							recordSpecifier.value.setUTF16String(@"NO");
						}
						recordSpecifier.isOK = true;
						break;
					case 5://nextAlarmDate
						recordSpecifier.value.setUTF16String([task.nextAlarmDate description]);
						recordSpecifier.isOK = true;
						break;
					case 6://calendar
						recordSpecifier.value.setUTF16String([task.calendar uid]);
						recordSpecifier.isOK = true;
						break;
					case 7://dateStamp
						recordSpecifier.value.setUTF16String([task.dateStamp description]);
						recordSpecifier.isOK = true;
						break;
					case 8://notes
						recordSpecifier.value.setUTF16String(task.notes);
						recordSpecifier.isOK = true;
						break;
					case 9://title
						recordSpecifier.value.setUTF16String(task.title);
						recordSpecifier.isOK = true;
						break;
					case 10://url
						recordSpecifier.value.setUTF16String([task.url absoluteString]);
						recordSpecifier.isOK = true;
						break;
						
					default:
						break;
				}
				
			}
			recordSpecifier.isDone = true;
		}
	}
    
    void reloadCalendars()
    {
        iCalApplication *iCal = [SBApplication applicationWithBundleIdentifier:@"com.apple.iCal"];
        [iCal reloadCalendars];
    }

    NSString *emailRegex =
    @"(?:[a-z0-9!#$%\\&'*+/=?\\^_`{|}~-]+(?:\\.[a-z0-9!#$%\\&'*+/=?\\^_`{|}"
    @"~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\"
    @"x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-"
    @"z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5"
    @"]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-"
    @"9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21"
    @"-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])";
    
    NSPredicate *emailPredicate = [NSPredicate predicateWithFormat:@"SELF MATCHES[c] %@", emailRegex];
    /* https://stackoverflow.com/questions/800123/what-are-best-practices-for-validating-email-addresses-on-ios-2-0 */
    
    #define CMD_DELAY_PROCESS 323
    
    void PA_PutProcessToSleep2(PA_long32 process, double delay)
    {
        PA_Variable params[2];
        params[0] = PA_CreateVariable(eVK_Longint);
        PA_SetLongintVariable(&params[0], process);
        
        params[1] = PA_CreateVariable(eVK_Real);
        PA_SetRealVariable(&params[1], delay);
        
        PA_ExecuteCommandByID(CMD_DELAY_PROCESS, params, 2);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
    }
    
#pragma mark AppleScript v2

    void show_task(NSString *calendar_id,
                    NSString *task_id)
    {
        NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.iCal"];
        if(thisBundle)
        {
            NSString *scriptPath = [thisBundle
                                    pathForResource:@"show_task"
                                    ofType:@"scpt"
                                    inDirectory:@"scpt"];
            if(scriptPath)
            {
                NSTask *task = [[NSTask alloc]init];
                task.launchPath = @"/usr/bin/osascript";
                
                task.arguments = @[scriptPath,
                                   calendar_id,
                                   task_id];
                
                BOOL __block isRunning = YES;
                
                task.terminationHandler = ^(NSTask *task)
                {
                    NSLog(@"process %d terminated with status %d", [task processIdentifier], [task terminationStatus]);
                    isRunning = NO;
                };
                [task launch];
                
                PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
                
                while(isRunning)
                {
                    PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
                }
                [task release];
            }
        }
    }
    
    void show_event(NSString *calendar_id,
                    NSString *event_id)
    {
        NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.iCal"];
        if(thisBundle)
        {
            NSString *scriptPath = [thisBundle
                                    pathForResource:@"show_event"
                                    ofType:@"scpt"
                                    inDirectory:@"scpt"];
            if(scriptPath)
            {
                NSTask *task = [[NSTask alloc]init];
                task.launchPath = @"/usr/bin/osascript";
                
                task.arguments = @[scriptPath,
                                   calendar_id,
                                   event_id];
                
                BOOL __block isRunning = YES;
                
                task.terminationHandler = ^(NSTask *task)
                {
                    NSLog(@"process %d terminated with status %d", [task processIdentifier], [task terminationStatus]);
                    isRunning = NO;
                };
                [task launch];
                
                PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
                
                while(isRunning)
                {
                    PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
                }
                [task release];
            }
        }
    }
    
    void show_date(NSString *yyyy, NSString *mm, NSString *dd)
    {
        NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.iCal"];
        if(thisBundle)
        {
            NSString *scriptPath = [thisBundle
                                    pathForResource:@"show_date"
                                    ofType:@"scpt"
                                    inDirectory:@"scpt"];
            if(scriptPath)
            {
                NSTask *task = [[NSTask alloc]init];
                task.launchPath = @"/usr/bin/osascript";
                
                task.arguments = @[scriptPath,
                                   yyyy,
                                   mm,
                                   dd];
                
                BOOL __block isRunning = YES;
                
                task.terminationHandler = ^(NSTask *task)
                {
                    NSLog(@"process %d terminated with status %d", [task processIdentifier], [task terminationStatus]);
                    isRunning = NO;
                };
                [task launch];
                
                PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
                
                while(isRunning)
                {
                    PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
                }
                [task release];
            }
        }
    }
    
    void switch_view(NSString *view)
    {
        NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.iCal"];
        if(thisBundle)
        {
            NSString *scriptPath = [thisBundle
                                    pathForResource:@"switch_view"
                                    ofType:@"scpt"
                                    inDirectory:@"scpt"];
            if(scriptPath)
            {
                NSTask *task = [[NSTask alloc]init];
                task.launchPath = @"/usr/bin/osascript";
                
                task.arguments = @[scriptPath,
                                   view];
                
                BOOL __block isRunning = YES;
                
                task.terminationHandler = ^(NSTask *task)
                {
                    NSLog(@"process %d terminated with status %d", [task processIdentifier], [task terminationStatus]);
                    isRunning = NO;
                };
                [task launch];
                
                PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
                
                while(isRunning)
                {
                    PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
                }
                [task release];
            }
        }
    }
    
    void add_attendee(NSString *calendar_id,
                      NSString *event_id,
                      NSString *attendee_name,
                      NSString *attendee_email,
                      NSString *attendee_status)
    {
        NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.iCal"];
        if(thisBundle)
        {
            NSString *scriptPath = [thisBundle
                                    pathForResource:@"add_attendee"
                                    ofType:@"scpt"
                                    inDirectory:@"scpt"];
            if(scriptPath)
            {
                if(attendee_email)
                {
                    if([attendee_email length])
                    {
                        if([emailPredicate evaluateWithObject:attendee_email])
                        {
                            NSTask *task = [[NSTask alloc]init];
                            task.launchPath = @"/usr/bin/osascript";
                            
                            task.arguments = @[scriptPath,
                                               calendar_id,
                                               event_id,
                                               attendee_name ? attendee_name : @"",
                                               attendee_email,
                                               attendee_status ? attendee_status : @""];
                            
                            BOOL __block isRunning = YES;
                            
                            task.terminationHandler = ^(NSTask *task)
                            {
                                NSLog(@"process %d terminated with status %d", [task processIdentifier], [task terminationStatus]);
                                isRunning = NO;
                            };
                            [task launch];
                            
                            PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
                            
                            while(isRunning)
                            {
                                PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
                            }
                            [task release];
                            
                        }else{
                            NSLog(@"invalid email string %@", attendee_email);
                        }
                    }
                }
            }
        }
    }
    
#pragma mark -
    
	void countTaskAlarms(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		if(defaultCalendarStore){
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
		
			if(task){
				recordSpecifier.count = [[task alarms]count];
				recordSpecifier.isOK = true;
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getTaskAlarm(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			
			CalTask *task = [defaultCalendarStore taskWithUID:recordSpecifier.uid];
			
			if(task){
				int count = [[task alarms]count];
				int index = recordSpecifier.index;
				
				if((count >= index) && (index > 0)){
					CalAlarm *alarm = [[task alarms]objectAtIndex:(NSUInteger)(index - 1)];
					NSString *alarmString = copyAlarmString(alarm);
					recordSpecifier.value.setUTF16String(alarmString);
					[alarmString release];
					recordSpecifier.isOK = true;
				}else{
					NSLog(@"invalid alarm index: %i", index);
				}
				
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getEventAlarm(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:nil];
			if(event){
				int count = [[event alarms]count];
				int index = recordSpecifier.index;
				
				if((count >= index) && (index > 0)){
					CalAlarm *alarm = [[event alarms]objectAtIndex:(NSUInteger)(index - 1)];
					NSString *alarmString = copyAlarmString(alarm);
					recordSpecifier.value.setUTF16String(alarmString);
					[alarmString release];
					recordSpecifier.isOK = true;
				}else{
					NSLog(@"invalid alarm index: %i", index);
				}
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void countEventAlarms(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalEvent *event = [defaultCalendarStore eventWithUID:recordSpecifier.uid occurrence:nil];
			if(event){
				recordSpecifier.count = [[event alarms]count];
			}
		}
		recordSpecifier.isDone = true;
	}
	
	void getAlarmProperty(){
		C_LONGINT returnValue;
		CalCalendarStore *defaultCalendarStore = getCalendarStore(returnValue);
		
		if(defaultCalendarStore){
			CalAlarm *alarm = getAlarmFromString(recordSpecifier.uid);
			NSArray *alarmProperties = [NSArray arrayWithObjects:
																	@"action", @"absoluteTrigger",
																	@"emailAddress", @"relativeTrigger",
																	@"sound", @"url", nil];
			if(alarm){
				NSUInteger pid = [alarmProperties indexOfObject:recordSpecifier.key];
				
				switch (pid){
						
					case 0://action
						if(alarm.action){
							recordSpecifier.value.setUTF16String(alarm.action);
							recordSpecifier.isOK = true;
						}
						break;
					case 1://absoluteTrigger
						if(alarm.absoluteTrigger){
							recordSpecifier.value.setUTF16String([alarm.absoluteTrigger description]);
							recordSpecifier.isOK = true;
						}
						break;
					case 2://emailAddress
						if(alarm.emailAddress){
							recordSpecifier.value.setUTF16String(alarm.emailAddress);
							recordSpecifier.isOK = true;
						}
						break;
					case 3://relativeTrigger
						if(alarm.relativeTrigger){
                            @autoreleasepool
                            {
                                NSString *relativeTrigger = [NSString stringWithFormat:@"%f", alarm.relativeTrigger];
                                recordSpecifier.value.setUTF16String(relativeTrigger);
                            }
							recordSpecifier.isOK = true;
						}
						break;
					case 4://sound
						if(alarm.sound){
							recordSpecifier.value.setUTF16String(alarm.sound);
							recordSpecifier.isOK = true;
						}
						break;
					case 5://url
						if(alarm.url){
							recordSpecifier.value.setUTF16String([alarm.url absoluteString]);
							recordSpecifier.isOK = true;
						}
						break;
				}
				
			}
			
		}
		recordSpecifier.isDone = true;
		
	}
	
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
		
	}
	catch(...)
	{
		
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			onStartup();
			break;
		case kCloseProcess :
			onCloseProcess();
			break;
// --- Event

		case 1 :
			iCal_Create_event(pResult, pParams);
			break;

		case 2 :
			iCal_Set_event_property(pResult, pParams);
			break;

		case 3 :
			iCal_Get_event_property(pResult, pParams);
			break;

		case 4 :
			iCal_Remove_event(pResult, pParams);
			break;

// --- Task

		case 5 :
			iCal_Create_task(pResult, pParams);
			break;

		case 6 :
			iCal_Set_task_property(pResult, pParams);
			break;

		case 7 :
			iCal_Get_task_property(pResult, pParams);
			break;

		case 8 :
			iCal_Remove_task(pResult, pParams);
			break;

// --- Calendar

		case 9 :
			iCal_Create_calendar(pResult, pParams);
			break;

		case 10 :
			iCal_Set_calendar_property(pResult, pParams);
			break;

		case 11 :
			iCal_Get_calendar_property(pResult, pParams);
			break;

		case 12 :
			iCal_Remove_calendar(pResult, pParams);
			break;

// --- Calendar Store

		case 13 :
			iCal_QUERY_EVENT(pResult, pParams);
			break;

		case 14 :
			iCal_GET_CALENDAR_LIST(pResult, pParams);
			break;

		case 15 :
			iCal_QUERY_TASK(pResult, pParams);
			break;

// --- Type Cast

		case 16 :
			iCal_Make_date(pResult, pParams);
			break;

		case 17 :
			iCal_GET_DATE(pResult, pParams);
			break;

		case 18 :
			iCal_Make_color(pResult, pParams);
			break;

		case 19 :
			iCal_GET_COLOR(pResult, pParams);
			break;

		case 20 :
			iCal_Make_color_from_index(pResult, pParams);
			break;

// --- Recurrence Rule

		case 21 :
			iCal_Remove_event_recurrence(pResult, pParams);
			break;

		case 22 :
			iCal_Set_event_recurrence(pResult, pParams);
			break;

// --- Alarm

		case 23 :
			iCal_Make_alarm(pResult, pParams);
			break;

		case 24 :
			iCal_Get_alarm_property(pResult, pParams);
			break;

		case 25 :
			iCal_Set_alarm_property(pResult, pParams);
			break;

		case 26 :
			iCal_Add_alarm_to_event(pResult, pParams);
			break;

		case 27 :
			iCal_Add_alarm_to_task(pResult, pParams);
			break;

// --- Application

		case 28 :
			iCal_TERMINATE(pResult, pParams);
			break;

		case 29 :
			iCal_LAUNCH(pResult, pParams);
			break;

// --- iCal Direct

		case 30 :
			iCal_SHOW_EVENT(pResult, pParams);
			break;

		case 31 :
			iCal_SHOW_TASK(pResult, pParams);
			break;

		case 32 :
			iCal_SET_VIEW(pResult, pParams);
			break;

		case 33 :
			iCal_SHOW_DATE(pResult, pParams);
			break;

		case 34 :
			iCal_app_Get_task_property(pResult, pParams);
			break;

		case 35 :
			iCal_app_Get_event_property(pResult, pParams);
			break;

// --- Notification

		case 36 :
			iCal_Set_notification_method(pResult, pParams);
			break;

		case 37 :
			iCal_Get_notification_method(pResult, pParams);
			break;

// --- Alarm II

		case 38 :
			iCal_Get_event_alarm(pResult, pParams);
			break;

		case 39 :
			iCal_Count_event_alarms(pResult, pParams);
			break;

		case 40 :
			iCal_Remove_event_alarm(pResult, pParams);
			break;

		case 41 :
			iCal_Set_event_alarm(pResult, pParams);
			break;

		case 42 :
			iCal_Count_task_alarms(pResult, pParams);
			break;

		case 43 :
			iCal_Get_task_alarm(pResult, pParams);
			break;

		case 44 :
			iCal_Remove_task_alarm(pResult, pParams);
			break;

		case 45 :
			iCal_Set_task_alarm(pResult, pParams);
			break;

// --- Timezone

		case 46 :
			iCal_TIMEZONE_LIST(pResult, pParams);
			break;

		case 47 :
			iCal_Get_timezone_info(pResult, pParams);
			break;

		case 48 :
			iCal_Get_timezone_for_offset(pResult, pParams);
			break;

		case 49 :
			iCal_Get_system_timezone(pResult, pParams);
			break;

// --- Event II

		case 50 :
			iCal_Set_event_properties(pResult, pParams);
			break;
            
// --- v2
            
        case 51 :
            iCal_Get_calendars(pResult, pParams);
            break;
            
        case 52 :
            iCal_Get_timezones(pResult, pParams);
            break;
            
        case 53 :
            iCal_Add_event(pResult, pParams);
            break;
            
        case 54 :
            iCal_Modify_event(pResult, pParams);
            break;
            
        case 55 :
            iCal_Find_event(pResult, pParams);
            break;
	}
}

#pragma mark Event

void iCal_Create_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	ARRAY_TEXT Param4;
	ARRAY_TEXT Param5;
	C_TEXT returnValue;
	C_LONGINT returnValueInternal;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);

	NSError *error = nil;
	
	CalCalendar *calendar;
	
	NSString *calendarId = Param1.copyUTF16String();
	NSString *startDateString = Param2.copyUTF16String();
	NSString *endDateString = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValueInternal);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValueInternal);
		if(calendar){
			CalEvent *event = [CalEvent event];
			NSDate *startDate = iCal::getDate(startDateString, returnValueInternal);
			NSDate *endDate = iCal::getDate(endDateString, returnValueInternal);
			if((startDate) && (endDate)){
				event.startDate = startDate;
				event.endDate = endDate;
				if(Param4.getSize() == Param5.getSize()){
					unsigned int len = Param4.getSize();
					for (unsigned int i = 0; i < len;++i){
						CUTF16String _key, _value;
						Param4.copyUTF16StringAtIndex(&_key, i);
						Param5.copyUTF16StringAtIndex(&_value, i);
						NSString *key = [[NSString alloc]initWithCharacters:(const unichar *)_key.c_str() length:_key.length()];
						NSString *value = [[NSString alloc]initWithCharacters:(const unichar *)_value.c_str() length:_value.length()];
						iCal::setEventProperty(event, key, value);
						[key release];
						[value release];
					}
				}
				event.calendar = calendar;
				if(![defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error]){
					NSLog(@"can't save event: %@", [error localizedDescription]);
				}else{
					returnValue.setUTF16String([event uid]);
				}
			}else{
				NSLog(@"invalid start date: %@, end date: %@", startDateString, endDateString);
			}
		}else{
			NSLog(@"invalid calendar: %@", calendarId);
		}
	}
	
	[calendarId release];
	[startDateString release];
	[endDateString release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	NSString *date = Param4.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:[NSDate dateWithString:date]];
		if(event){
			iCal::setEventProperty(event, key, value);
			success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[key release];
	[value release];
	[date release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				iCal::recordSpecifier.date = Param4.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getEventProperty, 0, @"$iCal_Get_event_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				[iCal::recordSpecifier.date release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);

}

void iCal_Remove_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			success = [defaultCalendarStore removeEvent:event span:CalSpanAllEvents error:&error];
			if(error){
				success = [error code];
				NSLog(@"can't remove event: %@", [error localizedDescription]);
			}
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_properties(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *date = Param4.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:[NSDate dateWithString:date]];
		if(event){
			
			if(Param2.getSize() == Param3.getSize()){
				unsigned int len = Param2.getSize();
				for (unsigned int i = 0; i < len;++i){
					CUTF16String _key, _value;
					Param2.copyUTF16StringAtIndex(&_key, i);
					Param3.copyUTF16StringAtIndex(&_value, i);
					NSString *key = [[NSString alloc]initWithCharacters:(const unichar *)_key.c_str() length:_key.length()];
					NSString *value = [[NSString alloc]initWithCharacters:(const unichar *)_value.c_str() length:_value.length()];
					iCal::setEventProperty(event, key, value);
					[key release];
					[value release];
				}
				success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
			}
			
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[date release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Task

void iCal_Create_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSError *error = nil;
	
	CalCalendar *calendar;
	
	NSString *calendarId = Param1.copyUTF16String();
	NSString *dueDateString = Param2.copyUTF16String();
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, _returnValue);
		if(calendar){
			CalTask *task = [CalTask task];
			task.calendar = calendar;
			
			NSDate *dueDate = [NSDate dateWithString:dueDateString];
			
			if(dueDate) task.dueDate = dueDate;
			
			[defaultCalendarStore saveTask:task error:&error];
			
			if(error){
				NSLog(@"can't save task: %@", [error localizedDescription]);
			}else{
				returnValue.setUTF16String([task uid]);
			}
		}
	}
	
	[calendarId release];
	[dueDateString release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalTask *task = [defaultCalendarStore taskWithUID:uid];
		NSArray *taskProperties = [NSArray arrayWithObjects:
															 @"dueDate", @"isCompleted",
															 @"priority", @"completedDate" ,
															 @"hasAlarm", @"nextAlarmDate",
															 @"calendar", @"dateStamp",
															 @"notes", @"title",
															 @"url", nil];
		if(task){
			NSUInteger pid = [taskProperties indexOfObject:key];
			
			switch (pid){
				case 0://dueDate
					task.dueDate = [NSDate dateWithString:value];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 1://isCompleted
					task.isCompleted = [value boolValue];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 2://priority
					task.priority = [value integerValue];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 3://completedDate
					task.completedDate = [NSDate dateWithString:value];
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 4://hasAlarm (readonly)
					break;
				case 5://nextAlarmDate (readonly)
					break;
				case 6://calendar
				{
					CalCalendar *calendar = [defaultCalendarStore calendarWithUID:value];
					if(calendar){
						task.calendar = calendar;
						success = [defaultCalendarStore saveTask:task error:&error];
					}
				}
					break;
				case 7://dateStamp (readonly)
					break;
				case 8://notes
					task.notes = value;
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 9://title
					task.title = value;
					success = [defaultCalendarStore saveTask:task error:&error];
					break;
				case 10://url
				{
					NSURL *url = [NSURL URLWithString:value];
					if(url){
						task.url = url;
						success = [defaultCalendarStore saveTask:task error:&error];
					}
				}
					break;
					
				default:
					break;
			}
			
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update task: %@", [error localizedDescription]);
		}
	}
	
	[uid release];
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getTaskProperty, 0, @"$iCal_Get_task_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				[iCal::recordSpecifier.date release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString * taskId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [[CalCalendarStore defaultCalendarStore]taskWithUID:taskId];
		
		if(task) success = [[CalCalendarStore defaultCalendarStore]removeTask:task error:&error];
		
		if(error){
			success = [error code];
			NSLog(@"can't remove task: %@", [error localizedDescription]);
		}
	}
	
	[taskId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		if(task){
			int count = [[task alarms]count];
			int index = Param2.getIntValue();
			
			if((count >= index) && (index > 0)){
				CalAlarm *alarm = [[task alarms]objectAtIndex:(NSUInteger)(index - 1)];
				[task removeAlarm:alarm];
				success = 1;
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
			
		}else{
			success = [error code];
			NSLog(@"invalid task: %@", taskId);
		}
	}
	
	[taskId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	NSString *dictionary = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		if(task){
			
			int count = [[task alarms]count];
			int index = Param2.getIntValue();
			
			if((count >= index) && (index > 0)){
				
				NSMutableArray *alarms = [[task alarms]mutableCopy];
				CalAlarm *newAlarm = iCal::getAlarmFromString(dictionary);
				
				if(newAlarm){
					[alarms replaceObjectAtIndex:(NSUInteger)(index - 1) withObject:newAlarm];
					[task removeAlarms:[task alarms]];
					[task addAlarms:alarms];
					success = [defaultCalendarStore saveTask:task error:&error];
				}
				
				[alarms release];
				
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
			
		}else{
			success = [error code];
			NSLog(@"invalid task: %@", taskId);
		}
	}
	
	[taskId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Calendar

void iCal_Create_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSError *error = nil;
	
	NSString *title = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	NSColor *color;
	
	CalCalendar *calendar = [CalCalendar calendar];
	
	calendar.title = title;
	
	color = iCal::getColorFromString(dictionary);
	if(color)	calendar.color = color;
	
	[[CalCalendarStore defaultCalendarStore]saveCalendar:calendar error:&error];
	
	if(error){
		NSLog(@"can't save calendar: %@", [error localizedDescription]);
	}else{
		returnValue.setUTF16String([calendar uid]);
	}
	
	[title release];
	[dictionary release];
	
	returnValue.setReturn(pResult);
}

void iCal_Set_calendar_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	CalCalendar *calendar;
	
	NSString * calendarId = Param1.copyUTF16String();
	NSString * key = Param2.copyUTF16String();
	NSString * value = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if (defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValue);
		if(calendar){
			NSColor *color;
			
			NSArray *calendarProperties = [NSArray arrayWithObjects:
																		 @"color", @"isEditable",
																		 @"notes", @"title",
																		 @"type", nil];
			NSUInteger pid = [calendarProperties indexOfObject:key];
			switch (pid){
				case 0://color
					color = iCal::getColorFromString(value);
					if(color){
						calendar.color = color;
						success = [defaultCalendarStore saveCalendar:calendar error:&error];
					}
					break;
				case 1://isEditable (readonly)
					break;
				case 2://notes
					calendar.notes = value;
					success = [defaultCalendarStore saveCalendar:calendar error:&error];
					break;
				case 3://title
					calendar.title = value;
					success = [defaultCalendarStore saveCalendar:calendar error:&error];
					break;
				case 4://type (readonly)
					break;
				default:
					break;
			}
			if(error){
				success = [error code];
				NSLog(@"can't update calendar: %@", [error localizedDescription]);
			}
		}
	}
	
	[calendarId release];
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_calendar_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();
				
				iCal::newProcess((void *)iCal::getCalendarProperty, 0, @"$iCal_Get_calendar_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
		
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSError *error = nil;
	CalCalendar *calendar;
	
	NSString * calendarId = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		calendar = iCal::getCalendar(defaultCalendarStore, calendarId, returnValue);
		if(calendar){
			success = [defaultCalendarStore removeCalendar:calendar error:&error];
			if(error){
				success = [error code];
				NSLog(@"can't remove calendar: %@", [error localizedDescription]);
			}
		}
	}
	
	[calendarId release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Query


void iCal_QUERY_EVENT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	ARRAY_TEXT Param3;
	ARRAY_TEXT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		
		NSString *startDateString = Param1.copyUTF16String();
		NSString *endDateString = Param2.copyUTF16String();
		NSDate *startDate = [NSDate dateWithString:startDateString];
		NSDate *endDate = [NSDate dateWithString:endDateString];
		NSArray *calendars = iCal::getCalendars(defaultCalendarStore, Param3);
		[startDateString release];
		[endDateString release];
		
		NSPredicate *predicate;
		
		if((startDate) && (endDate)){
			
			predicate = [CalCalendarStore eventPredicateWithStartDate:startDate endDate:endDate calendars:calendars];
			
			Param4.appendUTF16String(@"");
			
			if(predicate){
				NSArray *events = [[CalCalendarStore defaultCalendarStore]eventsWithPredicate:predicate];
				for(unsigned int i = 0; i < [events count]; ++i){
					Param4.appendUTF16String([[events objectAtIndex:i]uid]);
				}
			}
		}
	}
	Param4.toParamAtIndex(pParams, 4);
}

void iCal_GET_CALENDAR_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	ARRAY_TEXT Param2;
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		NSArray *calendars = [defaultCalendarStore calendars];
		Param1.appendUTF16String(@"");
		Param2.appendUTF16String(@"");
		for(unsigned int i = 0; i < [calendars count]; ++i){
			Param1.appendUTF16String([[calendars objectAtIndex:i]uid]);
			Param2.appendUTF16String([[calendars objectAtIndex:i]title]);
		}
	}
	
	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
}

void iCal_QUERY_TASK(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	C_LONGINT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param4.fromParamAtIndex(pParams, 4);
	
	C_LONGINT _returnValue;
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
	
	if(defaultCalendarStore){
		
		NSString *dueDateString = Param1.copyUTF16String();
		NSDate *dueDate = [NSDate dateWithString:dueDateString];
		[dueDateString release];
		
		NSArray *calendars = iCal::getCalendars(defaultCalendarStore, Param2);
		
		NSPredicate *predicate;
		
		switch (Param4.getIntValue()){
			case 1:
				if(dueDate){
					predicate = [CalCalendarStore taskPredicateWithTasksCompletedSince:dueDate calendars:calendars];
				}else{
					predicate = [CalCalendarStore taskPredicateWithTasksCompletedSince:[NSDate distantPast] calendars:calendars];
				}
				break;
			default:
				if(dueDate){
					predicate = [CalCalendarStore taskPredicateWithUncompletedTasksDueBefore:dueDate calendars:calendars];
				}else{
					predicate = [CalCalendarStore taskPredicateWithUncompletedTasks:calendars];
				}
				break;
		}
		
		Param3.appendUTF16String(@"");
		
		if(predicate){
			NSArray *tasks = [defaultCalendarStore tasksWithPredicate:predicate];
			for(unsigned int i = 0; i < [tasks count]; ++i){
				Param3.appendUTF16String([[tasks objectAtIndex:i]uid]);
			}
		}
	}
	Param3.toParamAtIndex(pParams, 3);
}

#pragma mark Type Cast

void iCal_Make_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_TEXT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	PA_Date date;
	date.fYear = Param1.getYear();
	date.fMonth = Param1.getMonth();
	date.fDay = Param1.getDay();
	
	int seconds = Param2.getSeconds();
	NSString *name = Param3.copyUTF16String();
	
	NSString *description = iCal::copyDateTimeZoneString(&date, seconds, name);
	
	returnValue.setUTF16String(description);
	returnValue.setReturn(pResult);
	
	[description release];
	[name release];
}

void iCal_GET_DATE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT Param4;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *dateString = Param1.copyUTF16String();
	
	PA_Date date;
	int time = 0;
	int offset = 0;
	
	iCal::getDateTimeOffsetFromString(dateString, &date, &time, &offset);
	
	Param2.setYearMonthDay(date.fYear, date.fMonth, date.fDay);
	Param3.setSeconds(time);
	Param4.setIntValue(offset);
	
	[dateString release];
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
}

void iCal_Make_color(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_REAL Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	float red = Param1.getDoubleValue();
	float green = Param2.getDoubleValue();
	float blue = Param3.getDoubleValue();
	float alpha = Param4.getDoubleValue();
	
	NSColor *color = [NSColor colorWithDeviceRed:red green:green blue:blue alpha:alpha];
	NSString *colorString = iCal::copyColorString(color);
	
	returnValue.setUTF16String(colorString);
	returnValue.setReturn(pResult);
	
	[colorString release];
}

void iCal_GET_COLOR(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_REAL Param5;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSString *colorString = Param1.copyUTF16String();
	NSColor *color = iCal::getColorFromString(colorString);
	
	Param2.setDoubleValue((double)[color redComponent]);
	Param3.setDoubleValue((double)[color greenComponent]);
	Param4.setDoubleValue((double)[color blueComponent]);
	Param5.setDoubleValue((double)[color alphaComponent]);
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	
	[colorString release];
}

void iCal_Make_color_from_index(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSColor *color = iCal::getColorIndex(Param1.getIntValue());
	NSString *colorString = iCal::copyColorString(color);
	
	returnValue.setUTF16String(colorString);
	returnValue.setReturn(pResult);
	
	[colorString release];
}

#pragma mark Recurrence Rule

void iCal_Remove_event_recurrence(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			event.recurrenceRule = nil;
			success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:NULL];
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_recurrence(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_TEXT Param5;
	C_TEXT Param6;
	C_TEXT Param7;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);
	Param6.fromParamAtIndex(pParams, 6);
	Param7.fromParamAtIndex(pParams, 7);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *type = Param2.copyUTF16String();
	NSUInteger interval = Param3.getIntValue();
	NSString *dateString = Param4.copyUTF16String();
	NSString *param1 = Param5.copyUTF16String();
	NSString *param2 = Param6.copyUTF16String();
	NSString *param3 = Param7.copyUTF16String();
	NSDate *date = [NSDate dateWithString:dateString];
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			
			NSArray *ruleTypes = [NSArray arrayWithObjects:
														@"Daily", @"Weekly", @"Monthly", @"Yearly", nil];
			NSUInteger pid = [ruleTypes indexOfObject:type];
			CalRecurrenceRule *rule;
			NSArray *days;
			NSArray *months;
			
			switch (pid){
				case 0://Daily
					if(date){
						rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
					}else{
						if([dateString length]){
							rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
						}else{
							rule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:interval end:nil];
						}
					}
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
				case 1://Weekly
					days = [param1 componentsSeparatedByString:@","];
					if([days count]){
						if(date){
							rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval forDaysOfTheWeek:days end:nil];
							}
						}
					}else{
						if(date){
							rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:interval end:nil];
							}
						}
					}
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
				case 2://Monthly
					days = [param1 componentsSeparatedByString:@","];
					if([days count]){
						if(date){
							rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDaysOfTheMonth:days end:nil];
							}
						}
					}else{
						
						if(([param1 length])&&([param2 length])){
							if(date){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] end:nil];
								}
							}
						}else{
							if(date){
								rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:interval end:nil];
								}
							}
						}
					}
					
				case 3://Yearly
					days = [param1 componentsSeparatedByString:@","];
					months = [param3 componentsSeparatedByString:@","];
					if([months count]){
						
						if(date){
							rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
						}else{
							if([dateString length]){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
							}else{
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forDayOfTheWeek:[param1 integerValue] forWeekOfTheMonth:[param2 integerValue] forMonthsOfTheYear:months end:nil];
							}
						}
						
					}else{
						if([days count]){
							if(date){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval forMonthsOfTheYear:days end:nil];
								}
							}
						}else{
							if(date){
								rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithEndDate:date]];
							}else{
								if([dateString length]){
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:[CalRecurrenceEnd recurrenceEndWithOccurrenceCount:[dateString integerValue]]];
								}else{
									rule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:interval end:nil];
								}
							}
						}
					}
					
					event.recurrenceRule = rule;
					success = [[CalCalendarStore defaultCalendarStore]saveEvent:event span:CalSpanAllEvents error:&error];
					[rule release];
					break;
			}
			if(error){
				success = [error code];
				NSLog(@"can't update event: %@", [error localizedDescription]);
			}
		}
	}
	
	[uid release];
	[type release];
	[dateString release];
	[param1 release];
	[param2 release];
	[param3 release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Alarm

void iCal_Make_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	CalAlarm *alarm = [CalAlarm alarm];
	NSString *alarmString = iCal::copyAlarmString(alarm);
	
	returnValue.setUTF16String(alarmString);
	returnValue.setReturn(pResult);
	
	[alarmString release];
}

void iCal_Get_alarm_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.key = Param2.copyUTF16String();

				iCal::newProcess((void *)iCal::getAlarmProperty, 0, @"$iCal_Get_alarm_property");
				
				[iCal::recordSpecifier.uid release];
				[iCal::recordSpecifier.key release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}

				iCal::recordSpecifier.isLocked = false;
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_alarm_property(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSString *dictionary = Param1.copyUTF16String();
	NSString *key = Param2.copyUTF16String();
	NSString *value = Param3.copyUTF16String();
	
	CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
	
	NSArray *alarmProperties = [NSArray arrayWithObjects:
															@"action", @"absoluteTrigger",
															@"emailAddress", @"relativeTrigger" ,
															@"sound", @"url", nil];
	
	if(alarm){
		
		NSUInteger pid = [alarmProperties indexOfObject:key];
		NSDate *d = nil;
		NSURL *u = nil;
		
		switch (pid){
				
			case 0://action
				alarm.action = value;
				success = 1;
				break;
			case 1://absoluteTrigger
				d = [NSDate dateWithString:value];
				if(d){
					alarm.absoluteTrigger = d;
					success = 1;
				}
				break;
			case 2://emailAddress
				alarm.emailAddress = value;
				success = 1;
				break;
			case 3://relativeTrigger
				alarm.relativeTrigger = [value doubleValue];
				success = 1;
				break;
			case 4://sound
				alarm.sound = value;
				success = 1;
				break;
			case 5://url
				u = [[NSURL alloc]initWithString:value];
				if(u){
					if([u isFileURL]){
						alarm.url = u;
						success = 1;
					}
					[u release];
				}
				break;
		}
	}
	
	[dictionary release];
	dictionary = iCal::copyAlarmString(alarm);
	Param1.setUTF16String(dictionary);
	Param1.toParamAtIndex(pParams, 1);
	[dictionary release];
	
	[key release];
	[value release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Add_alarm_to_event(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSString *eventId = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	
	int success = 0;
	
	NSError *error = nil;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:eventId occurrence:nil];
		CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
		if(event){
			[event addAlarm:alarm];
			success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update event: %@", [error localizedDescription]);
		}
	}
	
	[eventId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Add_alarm_to_task(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *taskId = Param1.copyUTF16String();
	NSString *dictionary = Param2.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		CalTask *task = [defaultCalendarStore taskWithUID:taskId];
		CalAlarm *alarm = iCal::getAlarmFromString(dictionary);
		
		if(task){
			[task addAlarm:alarm];
			success = [defaultCalendarStore saveTask:task error:&error];
		}
		
		if(error){
			success = [error code];
			NSLog(@"can't update task: %@", [error localizedDescription]);
		}
		
	}
	
	[taskId release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.index = Param2.getIntValue();
				
				iCal::newProcess((void *)iCal::getEventAlarm, 0, @"$iCal_Get_event_alarm");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Count_event_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				
				iCal::newProcess((void *)iCal::countEventAlarms, 0, @"$iCal_Count_event_alarms");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param2.setIntValue(iCal::recordSpecifier.count);
					Param2.toParamAtIndex(pParams, 2);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Remove_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	NSString *uid = Param1.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			int count = [[event alarms]count];
			int index = Param2.getIntValue();
			if((count >= index) && (index > 0)){
				CalAlarm *alarm = [[event alarms]objectAtIndex:(NSUInteger)(index - 1)];
				[event removeAlarm:alarm];
				success = 1;
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
		}
	}
	
	[uid release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Set_event_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	int success = 0;
	
	NSError *error = nil;
	
	NSString *uid = Param1.copyUTF16String();
	NSString *dictionary = Param3.copyUTF16String();
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:nil];
		if(event){
			int count = [[event alarms]count];
			int index = Param2.getIntValue();
			if((count >= index) && (index > 0)){
				NSMutableArray *alarms = [[event alarms]mutableCopy];
				CalAlarm *newAlarm = iCal::getAlarmFromString(dictionary);
				if(newAlarm){
					[alarms replaceObjectAtIndex:(NSUInteger)(index - 1) withObject:newAlarm];
					[event removeAlarms:[event alarms]];
					[event addAlarms:alarms];
					success = [defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error];
				}
				[alarms release];
			}else{
				NSLog(@"invalid alarm index: %i", index);
			}
		}
	}
	
	[uid release];
	[dictionary release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Count_task_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				
				iCal::newProcess((void *)iCal::countTaskAlarms, 0, @"$iCal_Count_task_alarms");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param2.setIntValue(iCal::recordSpecifier.count);
					Param2.toParamAtIndex(pParams, 2);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

void iCal_Get_task_alarm(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	int success = 0;
	
	CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
	
	if(defaultCalendarStore){
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			if(!iCal::recordSpecifier.isLocked){
				iCal::recordSpecifier.isLocked = true;
				iCal::recordSpecifier.isDone = false;
				iCal::recordSpecifier.isOK = false;
				
				iCal::recordSpecifier.uid = Param1.copyUTF16String();
				iCal::recordSpecifier.index = Param2.getIntValue();
				
				iCal::newProcess((void *)iCal::getTaskAlarm, 0, @"$iCal_Get_task_alarm");
				
				[iCal::recordSpecifier.uid release];
				
				BOOL isDone = false;
				
				while (!isDone){
					PA_YieldAbsolute();
					isDone = (PA_IsProcessDying()) || iCal::recordSpecifier.isDone;
				}
				
				if(iCal::recordSpecifier.isOK){
					Param3.setUTF16String(iCal::recordSpecifier.value.getUTF16StringPtr(), iCal::recordSpecifier.value.getUTF16Length());
					Param3.toParamAtIndex(pParams, 3);
					success = 1;
				}
				
				iCal::recordSpecifier.isLocked = false;
				
			}else{
				NSLog(@"iCal bridge process is busy");
			}
			
			[l unlock];
			[l release];
		}
	}
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

#pragma mark Application v2

void iCal_TERMINATE(sLONG_PTR *pResult, PackagePtr pParams){
	//requires 10.6 or later
	
	if(NSClassFromString(@"NSRunningApplication")){
		NSArray *array = [NSRunningApplication runningApplicationsWithBundleIdentifier:@"com.apple.iCal"];
		if([array count])
			[(NSRunningApplication *)[array objectAtIndex:0] terminate];
	}
}

void iCal_LAUNCH(sLONG_PTR *pResult, PackagePtr pParams){
	[[NSWorkspace sharedWorkspace]launchApplication:@"iCal"];
}

void iCal_SHOW_EVENT(sLONG_PTR *pResult, PackagePtr pParams){
	
    C_TEXT Param1;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    NSString *eventId = Param1.copyUTF16String();
    
    C_LONGINT _returnValue;
    CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
    
    if(defaultCalendarStore)
    {
        CalEvent *event = [defaultCalendarStore eventWithUID:eventId occurrence:nil];
        if(event)
        {
            iCal::show_event(event.calendar.uid, event.uid);
        }
    }
    
    [eventId release];
}

void iCal_SHOW_TASK(sLONG_PTR *pResult, PackagePtr pParams){
	
    C_TEXT Param1;

    Param1.fromParamAtIndex(pParams, 1);

    NSString *taskId = Param1.copyUTF16String();
    
    C_LONGINT _returnValue;
    CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
    
    if(defaultCalendarStore)
    {
        CalTask *task = [defaultCalendarStore taskWithUID:taskId];
        if(task)
        {
            iCal::show_task(task.calendar.uid, task.uid);
        }
    }
    
    [taskId release];
}

void iCal_SET_VIEW(sLONG_PTR *pResult, PackagePtr pParams){
	
	BOOL useAppleScript = false;
	
	if(useAppleScript)
	{
        C_LONGINT Param1;
        
        Param1.fromParamAtIndex(pParams, 1);
        
        switch (Param1.getIntValue()){
            case 0:
                iCal::switch_view(@"Day");
                break;
            case 1:
                iCal::switch_view(@"Week");
                break;
            case 2:
                iCal::switch_view(@"Month");
                break;
            default:
                break;
        }
        
    }else{
        
        iCalApplication *iCal = [SBApplication applicationWithBundleIdentifier:@"com.apple.iCal"];
        
        C_LONGINT Param1;
        
        Param1.fromParamAtIndex(pParams, 1);
        
        switch (Param1.getIntValue()){
            case 0:
                [iCal switchViewTo:iCalCALViewTypeForScriptingDayView];
                break;
            case 1:
                [iCal switchViewTo:iCalCALViewTypeForScriptingWeekView];
                break;
            case 2:
                [iCal switchViewTo:iCalCALViewTypeForScriptingMonthView];
                break;
            default:
                break;
        }
    }
}

void iCal_SHOW_DATE(sLONG_PTR *pResult, PackagePtr pParams){
	
	C_DATE Param1;
	Param1.fromParamAtIndex(pParams, 1);
	
    short yyyy = Param1.getYear();
    short mm = Param1.getMonth();
    short dd = Param1.getDay();
    
    BOOL useAppleScript = false;
    
    if(useAppleScript)
    {
        NSString *yearValue = [[NSNumber numberWithShort:yyyy] stringValue];
        NSString *monthValue = [[NSNumber numberWithShort:mm] stringValue];
        NSString *dayValue = [[NSNumber numberWithShort:dd] stringValue];
        
        iCal::show_date(yearValue, monthValue, dayValue);
        
    }else
    {
        NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
        
        [GMT setDateFormat:DATE_FORMAT_ISO];
        [GMT setTimeZone:[NSTimeZone localTimeZone]];
        
        @autoreleasepool
        {
            iCalApplication *iCal = [SBApplication applicationWithBundleIdentifier:@"com.apple.iCal"];

            NSString *dateString = [NSString stringWithFormat:@"%04d-%02d-%02dT00:00:00", yyyy, mm, dd];
            NSDate *date = [GMT dateFromString:dateString];
            
            if(date)
            {
                [iCal viewCalendarAt:date];
            }
        }
        [GMT release];
    }
}

#pragma mark Not Implemented

void iCal_app_Get_task_property(sLONG_PTR *pResult, PackagePtr pParams)
{

}

void iCal_app_Get_event_property(sLONG_PTR *pResult, PackagePtr pParams)
{

}

#pragma mark Notification v2

// --------------------------------- Notification ---------------------------------

void iCal_Set_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        if(!Param1.getUTF16Length())
        {
            CalendarWatch::WATCH_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
            
            listenerLoopFinish();
        }else{
            CalendarWatch::WATCH_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());

            listenerLoopStart();
        }
    }
}

void iCal_Get_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
    CalendarWatch::WATCH_METHOD.setReturn(pResult);
}

#pragma mark Timezone

void iCal_TIMEZONE_LIST(sLONG_PTR *pResult, PackagePtr pParams)/* deprecated */
{
	ARRAY_TEXT Param1;
	
	NSArray *knownTimeZoneNames = [NSTimeZone knownTimeZoneNames];
	
	Param1.appendUTF16String(@"");
	
	for(unsigned int i = 0; i < [knownTimeZoneNames count]; i++)
	{
		Param1.appendUTF16String([knownTimeZoneNames objectAtIndex:i]);
	}
	
	Param1.toParamAtIndex(pParams, 1);
}

void iCal_Get_timezone_info(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_TEXT Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_DATE Param6;
	C_TIME Param7;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	NSString *name = Param3.copyUTF16String();
	NSTimeZone *zone = [NSTimeZone timeZoneWithName:name];
	if(!zone)
		zone = [NSTimeZone localTimeZone];
	[name release];
	
	CFGregorianDate gregDate;
	
	gregDate.year = Param1.getYear();
	gregDate.month = Param1.getMonth();
	gregDate.day = Param1.getDay();
	gregDate.hour = 0;
	gregDate.minute = 0;
	gregDate.second = 0;
	
	CFGregorianUnits offset;
	
	offset.years = 0;
	offset.months = 0;
	offset.days = 0;
	offset.minutes = 0;
	offset.hours = 0;
	offset.seconds = Param2.getSeconds();
	
	NSTimeInterval daylightSavingTimeOffsetForDate;
	NSInteger secondsFromGMTForDate;
	NSDate *nextDaylightSavingTimeTransitionAfterDate;
	
	if(CFGregorianDateIsValid(gregDate,
														kCFGregorianUnitsYears+kCFGregorianUnitsMonths+kCFGregorianUnitsDays)){
		
		CFAbsoluteTime at = CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)zone);
		CFAbsoluteTime seconds = CFAbsoluteTimeAddGregorianUnits(at, (CFTimeZoneRef)zone, offset);
		
		NSDate *nsd = (NSDate *)CFDateCreate(kCFAllocatorDefault, seconds);
		
		daylightSavingTimeOffsetForDate = [zone daylightSavingTimeOffsetForDate:nsd];
		secondsFromGMTForDate = [zone secondsFromGMTForDate:nsd];
		nextDaylightSavingTimeTransitionAfterDate = [zone nextDaylightSavingTimeTransitionAfterDate:nsd];
		
		[nsd release];
		
		Param4.setIntValue(secondsFromGMTForDate);
		Param5.setIntValue(daylightSavingTimeOffsetForDate);
		
		NSString *description = [nextDaylightSavingTimeTransitionAfterDate description];
		
		if([description length] == 25){
			
			int year = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
			int month = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
			int day = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
			
			int hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
			int minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
			int second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
			
			int offset = [zone secondsFromGMTForDate:nextDaylightSavingTimeTransitionAfterDate];
			
			Param6.setYearMonthDay(year, month, day);
			Param7.setSeconds(second + (minute * 60) + (hour * 3600) - offset);
			returnValue.setIntValue(1);
			
		}
		
	}
	
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
	Param7.toParamAtIndex(pParams, 7);
	returnValue.setReturn(pResult);
}

void iCal_Get_timezone_for_offset(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	returnValue.setUTF16String([[NSTimeZone timeZoneForSecondsFromGMT:Param1.getIntValue()]name]);
	
	returnValue.setReturn(pResult);
}

void iCal_Get_system_timezone(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT returnValue;
    
    returnValue.setUTF16String([[NSTimeZone systemTimeZone]name]);
    
    returnValue.setReturn(pResult);
}

#pragma mark v2

// -------------------------------------- v2 --------------------------------------

unsigned int getColorRGB(NSColor *color)
{
    unsigned int rgb = 0;
    
    if(color)
    {
        color = [color colorUsingColorSpace:[NSColorSpace displayP3ColorSpace]];
        
        /*
         color = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];//NSDeviceRGBColorSpace
         color = [color colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];
         color = [color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];//NSCalibratedRGBColorSpace
         */
        
        CGFloat red, green, blue, alpha;
        [color getRed:&red green:&green blue:&blue alpha:&alpha];
        
        rgb +=
        
        /*
         +((unsigned int)(red      * 255.99999f) << 16)
         +((unsigned int)(green    * 255.99999f) << 8)
         + (unsigned int)(blue     * 255.99999f);
         */
        
        +((unsigned int)floor((CGFloat)(red      * 0xFF) + 0.5f) << 16)
        +((unsigned int)floor((CGFloat)(green    * 0xFF) + 0.5f) << 8)
        + (unsigned int)floor((CGFloat)(blue     * 0xFF) + 0.5f);
    }
    
    return rgb;
}

void get_object_json(C_TEXT& returnValue, id object)
{
    if(object)
    {
        if([NSJSONSerialization isValidJSONObject:object])
        {
            NSData *jsonData = [NSJSONSerialization
                                dataWithJSONObject:object
                                options:0
                                error:NULL];
            if(jsonData)
            {
                /*
                 this can fail, NSData may not be null terminated
                 NSString *json = [NSString stringWithCString:(const char *)[jsonData bytes] encoding:NSUTF8StringEncoding];
                 */
                
                NSString *json = [[NSString alloc]initWithBytes:[jsonData bytes] length:[jsonData length] encoding:NSUTF8StringEncoding];
                if(json)
                {
                    returnValue.setUTF16String(json);
                    [json release];
                }
            }
        }
    }
}

void iCal_Get_calendars(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT returnValue;
    
    C_LONGINT _returnValue;
    CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(_returnValue);
    
    if(defaultCalendarStore)
    {
        CalCalendar *calendar = nil;
        
        NSMutableArray *array = [[NSMutableArray alloc]init];
        
        NSArray *calendars = [defaultCalendarStore calendars];
        
        for(unsigned int i = 0; i < [calendars count]; ++i)
        {
            if([[calendars objectAtIndex:i]isMemberOfClass:[CalCalendar class]])
            {
                calendar = [calendars objectAtIndex:i];
                
                NSString *title = calendar.title ? calendar.title : [NSNull null];
                NSString *uid = calendar.uid ? calendar.uid : [NSNull null];
                NSString *notes = calendar.notes ? calendar.notes : [NSNull null];
                NSString *type = calendar.type ? calendar.type : [NSNull null];
                NSNumber *isEditable = [NSNumber numberWithBool:calendar.isEditable];
                NSNumber *color = calendar.color ? [NSNumber numberWithInt:getColorRGB(calendar.color)] : [NSNumber numberWithInt:0];
                
                NSDictionary *item = [NSDictionary
                                      dictionaryWithObjects:[NSArray arrayWithObjects:
                                                             title, uid, notes, type, isEditable, color, nil]
                                      forKeys:[NSArray arrayWithObjects:
                                               @"title", @"uid", @"notes", @"type", @"isEditable", @"color", nil]];
                
                [array addObject:item];
            }
        }
        
        get_object_json(returnValue, array);
        
        [array release];
    }
    
    returnValue.setReturn(pResult);
}

void iCal_Get_timezones(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT returnValue;
    
    get_object_json(returnValue, [NSTimeZone knownTimeZoneNames]);
    
    returnValue.setReturn(pResult);
}

NSDate *parse_date(NSString *dateString)
{
    NSDate *date = nil;
    NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
    
    [GMT setDateFormat:DATE_FORMAT_ISO];
    [GMT setTimeZone:[NSTimeZone localTimeZone]];
    
    date = [GMT dateFromString:dateString];

    if(!date)
    {
        [GMT setDateFormat:DATE_FORMAT_ISO_GMT];
        [GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
        
        date = [GMT dateFromString:dateString];
    }
    
    [GMT release];
    
    return date;
}

void iCal_Add_event(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    NSError *error = nil;
    NSString *json = Param1.copyUTF16String();
    NSData *data = [json dataUsingEncoding:NSUTF8StringEncoding];
    if(data)
    {
        id obj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        if(obj)
        {
            if([obj isKindOfClass:[NSDictionary class]])
            {
                C_LONGINT returnValueInternal;
                CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValueInternal);
                
                if(defaultCalendarStore)
                {
                    CalCalendar *calendar = iCal::getCalendar(defaultCalendarStore, [obj valueForKey:@"calendar"], returnValueInternal);
                    if(calendar)
                    {
                        CalEvent *event = [CalEvent event];
                        
                        event.calendar = calendar;
                        
                        NSDate *startDate = parse_date([obj valueForKey:@"startDate"]);
                        NSDate *endDate = parse_date([obj valueForKey:@"endDate"]);
                        
                        if((startDate) && (endDate))
                        {
                            event.startDate = startDate;
                            event.endDate = endDate;
                           
                            if([obj valueForKey:@"isAllDay"])
                            {
                                event.isAllDay = [[obj valueForKey:@"isAllDay"]boolValue];
                            }
                            
                            NSString *_location = [obj valueForKey:@"location"];
                            NSString *_notes = [obj valueForKey:@"notes"];
                            NSString *_title = [obj valueForKey:@"title"];
                            NSURL *_url = [NSURL URLWithString:[obj valueForKey:@"url"]];;
                            
                            if(_location)
                            {
                                event.location = _location;
                            }
                            
                            if(_notes)
                            {
                                event.notes = _notes;
                            }

                            if(_title)
                            {
                                event.title = _title;
                            }

                            if(_url)
                            {
                                event.url = _url;
                            }

                            if(![defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error]){
                                NSLog(@"can't save event: %@", [error localizedDescription]);
                            }else{
                                
                                returnValue.setUTF16String(event.uid);
                                
                                /* add attendees */
                                
                                id _attendees = [obj valueForKey:@"attendees"];
                                if(_attendees)
                                {
                                    if([_attendees isKindOfClass:[NSArray class]])
                                    {
                                        /* it is not allowed to modify attendees */
                                        NSArray *attendees = (NSArray *)_attendees;
                                        
                                        for(NSUInteger a = 0; a < [attendees count];++a)
                                        {
                                            id _attendee = [attendees objectAtIndex:a];
                                            if([_attendee isKindOfClass:[NSDictionary class]])
                                            {
                                                NSDictionary *attendee = (NSDictionary *)_attendee;
                                                NSString *email = [attendee valueForKey:@"email"];
                                                NSString *displayName = [attendee valueForKey:@"displayName"];
                                                NSString *participationStatus = [attendee valueForKey:@"participationStatus"];
                                                
                                                iCal::add_attendee(calendar.uid, event.uid, displayName, email, participationStatus);
                                            }
                                        }
                                        iCal::reloadCalendars();
                                    }
                                }
                            }
                        }else{
                            NSLog(@"invalid start date: %@, end date: %@", [obj valueForKey:@"startDate"], [obj valueForKey:@"endDate"]);
                        }
                    }else{
                        NSLog(@"invalid calendar: %@", [obj valueForKey:@"calendar"]);
                    }
                }/* defaultCalendarStore */
            }/* [obj isKindOfClass:[NSDictionary class]] */
        }/* obj */
    }/* data */
    
    [json release];
    
    returnValue.setReturn(pResult);
}

void iCal_Modify_event(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    int success = 0;
    
    NSError *error = nil;
    NSString *json = Param1.copyUTF16String();
    NSData *data = [json dataUsingEncoding:NSUTF8StringEncoding];
    if(data)
    {
        id obj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        if(obj)
        {
            if([obj isKindOfClass:[NSDictionary class]])
            {
                CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValue);
                
                if(defaultCalendarStore)
                {
                    
                    NSString *uid = [obj valueForKey:@"uid"];
                    
                    if(uid)
                    {
                        NSString *dateString = Param2.copyUTF16String();
                        NSDate *date = parse_date(dateString);
                        [dateString release];
                        
                        CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:date];
                        
                        if(event)
                        {
                            BOOL touched = NO;
                            CalCalendar *calendar = iCal::getCalendar(defaultCalendarStore, [obj valueForKey:@"calendar"], returnValue);
                            if(calendar)
                            {
                                event.calendar = calendar;touched =YES;
                            }
                            
                            NSDate *startDate = parse_date([obj valueForKey:@"startDate"]);
                            NSDate *endDate = parse_date([obj valueForKey:@"endDate"]);
                            
                            if(startDate)
                            {
                                event.startDate = startDate;touched =YES;
                            }
                            if(endDate)
                            {
                                event.endDate = endDate;touched =YES;
                            }
                            if([obj valueForKey:@"isAllDay"])
                            {
                                event.isAllDay = [[obj valueForKey:@"isAllDay"]boolValue];touched =YES;
                            }
                            
                            NSString *_location = [obj valueForKey:@"location"];
                            NSString *_notes = [obj valueForKey:@"notes"];
                            NSString *_title = [obj valueForKey:@"title"];
                            NSURL *_url = [NSURL URLWithString:[obj valueForKey:@"url"]];;
                            
                            if(_location)
                            {
                                event.location = _location;touched =YES;
                            }
                            
                            if(_notes)
                            {
                                event.notes = _notes;touched =YES;
                            }
                            
                            if(_title)
                            {
                                event.title = _title;touched =YES;
                            }
                            
                            if(_url)
                            {
                                event.url = _url;touched =YES;
                            }
                            
                            if(touched)
                            {
                                if(![defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error]){
                                    success = [error code];
                                    NSLog(@"can't update event: %@", [error localizedDescription]);
                                }else{
                                    
                                }
                            }
                            
                            if(success == 0)
                            {
                                id _attendees = [obj valueForKey:@"attendees"];
                                if(_attendees)
                                {
                                    if([_attendees isKindOfClass:[NSArray class]])
                                    {
                                        /* it is not allowed to modify attendees */
                                        NSArray *attendees = (NSArray *)_attendees;
                                        
                                        for(NSUInteger a = 0; a < [attendees count];++a)
                                        {
                                            id _attendee = [attendees objectAtIndex:a];
                                            if([_attendee isKindOfClass:[NSDictionary class]])
                                            {
                                                NSDictionary *attendee = (NSDictionary *)_attendee;
                                                NSString *email = [attendee valueForKey:@"email"];
                                                NSString *displayName = [attendee valueForKey:@"displayName"];
                                                NSString *participationStatus = [attendee valueForKey:@"participationStatus"];
                                                
                                                iCal::add_attendee(calendar.uid, event.uid, displayName, email, participationStatus);
                                            }
                                        }
                                        iCal::reloadCalendars();
                                    }
                                }
                            }
                        }
                    }
                    
                }/* defaultCalendarStore */
            }/* [obj isKindOfClass:[NSDictionary class]] */
        }/* obj */
    }/* data */
    
    returnValue.setIntValue(success);
    returnValue.setReturn(pResult);
}

void iCal_Find_event(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT returnValue;
    C_LONGINT returnValueInternal;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CalCalendarStore *defaultCalendarStore = iCal::getCalendarStore(returnValueInternal);
    
    if(defaultCalendarStore)
    {
        NSString *uid = Param1.copyUTF16String();
        
        NSString *dateString = Param2.copyUTF16String();
        NSDate *date = parse_date(dateString);
        [dateString release];
        
        CalEvent *event = [defaultCalendarStore eventWithUID:uid occurrence:date];
        
        if(event)
        {
            CalAlarm *alarm = nil;
            
            NSMutableArray *array = [[NSMutableArray alloc]init];
            
            NSArray *alarms = [event alarms];
            
            for(unsigned int i = 0; i < [alarms count]; ++i)
            {
                if([[alarms objectAtIndex:i]isMemberOfClass:[CalAlarm class]])
                {
                    alarm = [alarms objectAtIndex:i];
                    
                    NSString *action = alarm.action ? alarm.action : [NSNull null];
                    NSString *absoluteTrigger = alarm.absoluteTrigger ? [alarm.absoluteTrigger description] : [NSNull null];
                    NSString *emailAddress = alarm.emailAddress ? alarm.emailAddress : [NSNull null];
                    NSNumber *relativeTrigger = alarm.relativeTrigger ? [NSNumber numberWithDouble:alarm.relativeTrigger] : [NSNull null];
                    NSString *sound = alarm.sound ? alarm.sound : [NSNull null];
                    NSString *url = alarm.url ? [alarm.url absoluteString] : [NSNull null];
                    
                    NSDictionary *item = [NSDictionary
                                          dictionaryWithObjects:[NSArray arrayWithObjects:
                                                                 action, absoluteTrigger, emailAddress, relativeTrigger, sound, url, nil]
                                          forKeys:[NSArray arrayWithObjects:
                                                   @"action", @"absoluteTrigger", @"emailAddress", @"relativeTrigger", @"sound", @"url", nil]];
                    
                    [array addObject:item];
                }
            }
            
            CalAttendee *attendee = nil;
            
            NSMutableArray *array2 = [[NSMutableArray alloc]init];
            
            NSArray *attendees = [event attendees];
            
            for(unsigned int i = 0; i < [attendees count]; ++i)
            {
                if([[attendees objectAtIndex:i]isMemberOfClass:[CalAttendee class]])
                {
                    attendee = [attendees objectAtIndex:i];
                    
                    NSString *addressString = attendee.address ? [attendee.address absoluteString] : [NSNull null];
                    NSString *statusString = @"unknown";
                    if(attendee.status)
                    {
                        if([attendee.status isEqualToString:CalAttendeeStatusNeedsAction]) statusString = @"unknown";
                        else
                            if([attendee.status isEqualToString:CalAttendeeStatusAccepted]) statusString = @"accepted";
                            else
                                if([attendee.status isEqualToString:CalAttendeeStatusDeclined]) statusString = @"declined";
                                else
                                    if([attendee.status isEqualToString:CalAttendeeStatusTentative]) statusString = @"tentative";
                    }

                    NSString *commonNameString = attendee.commonName ? attendee.commonName : [NSNull null];
                    
                    NSDictionary *item = [NSDictionary
                                          dictionaryWithObjects:[NSArray arrayWithObjects:
                                                                 statusString, commonNameString, addressString, nil]
                                          forKeys:[NSArray arrayWithObjects:
                                                   @"participationStatus", @"displayName", @"email", nil]];
                    
                    [array2 addObject:item];
                }
            }
            
            CalRecurrenceRule *recurrenceRule = event.recurrenceRule;
          
            NSNumber *recurrenceInterval = [NSNumber numberWithInt:0];
            NSString *firstDayOfTheWeek = nil;
            NSString *recurrenceType = nil;
            NSArray *daysOfTheWeek = @[];
            NSArray *daysOfTheMonth = @[];
            NSArray *nthWeekDaysOfTheMonth = @[];
            NSArray *monthsOfTheYear = @[];
            NSDictionary *recurrenceEnd = nil;
            
            if(recurrenceRule)
            {
                recurrenceInterval = [NSNumber numberWithInt:recurrenceRule.recurrenceInterval];
                firstDayOfTheWeek = [@[[NSNull null],
                                       @"Sunday",
                                       @"Monday",
                                       @"Tuesday",
                                       @"Wednesday",
                                       @"Thursday",
                                       @"Friday",
                                       @"Saturday"] objectAtIndex:recurrenceRule.firstDayOfTheWeek];
                recurrenceType = [@[@"Daily",
                                    @"Weekly",
                                    @"Monthly",
                                    @"Yearly"] objectAtIndex:recurrenceRule.recurrenceType];
                daysOfTheWeek = recurrenceRule.daysOfTheWeek ? recurrenceRule.daysOfTheWeek : @[];
                daysOfTheMonth = recurrenceRule.daysOfTheMonth ? recurrenceRule.daysOfTheMonth : @[];
                nthWeekDaysOfTheMonth = recurrenceRule.nthWeekDaysOfTheMonth ? recurrenceRule.nthWeekDaysOfTheMonth : @[];
                monthsOfTheYear = recurrenceRule.monthsOfTheYear ? recurrenceRule.monthsOfTheYear : @[];
                
                NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
                [GMT setDateFormat:DATE_FORMAT_ISO_GMT];
                [GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
                
                recurrenceEnd = recurrenceRule.recurrenceEnd ? @{
                                                                 @"occurrenceCount":[NSNumber numberWithInt:recurrenceRule.recurrenceEnd.occurrenceCount],
                                                                 @"endDate":recurrenceRule.recurrenceEnd.endDate ? [GMT stringFromDate:recurrenceRule.recurrenceEnd.endDate] : [NSNull null]
                                                                 } : [NSNull null];
                [GMT release];
            }
            
            NSDictionary *recurrence = @{
                                         @"recurrenceInterval":recurrenceInterval,
                                         @"firstDayOfTheWeek":firstDayOfTheWeek ? firstDayOfTheWeek : [NSNull null],
                                         @"recurrenceType":recurrenceType ? recurrenceType : [NSNull null],
                                         @"recurrenceEnd":recurrenceEnd ? recurrenceEnd : [NSNull null],
                                         @"daysOfTheWeek":daysOfTheWeek,
                                         @"daysOfTheMonth":daysOfTheMonth,
                                         @"nthWeekDaysOfTheMonth":nthWeekDaysOfTheMonth,
                                         @"monthsOfTheYear":monthsOfTheYear
                                         };
            
            NSString *calendar = event.calendar ? event.calendar.uid : [NSNull null];
            NSNumber *isAllDay = [NSNumber numberWithBool:event.isAllDay];
            NSString *location = event.location ? event.location : [NSNull null];
            NSString *notes = event.notes ? event.notes : [NSNull null];
            NSString *title = event.title ? event.title : [NSNull null];
            NSString *url = event.url ? [event.url absoluteString] : [NSNull null];
            
            NSDateFormatter *GMT = [[NSDateFormatter alloc]init];
            [GMT setDateFormat:DATE_FORMAT_ISO_GMT];
            [GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
            NSString *startDate = [GMT stringFromDate:event.startDate ? event.startDate : [NSNull null]];
            NSString *endDate = [GMT stringFromDate:event.endDate ? event.endDate : [NSNull null]];
            [GMT release];
            
            NSDictionary *item = [NSDictionary
                                  dictionaryWithObjects:[NSArray arrayWithObjects:
                                                         calendar,
                                                         isAllDay,
                                                         location,
                                                         notes,
                                                         title,
                                                         url,
                                                         startDate,
                                                         endDate,
                                                         array,
                                                         array2,
                                                         recurrence, nil]
                                  forKeys:[NSArray arrayWithObjects:
                                           @"calendar",
                                           @"isAllDay",
                                           @"location",
                                           @"notes",
                                           @"title",
                                           @"url",
                                           @"startDate",
                                           @"endDate",
                                           @"alarms",
                                           @"attendees",
                                           @"recurrence", nil]];
            
            get_object_json(returnValue, item);
            
            [array release];
            [array2 release];
            
        }/* event */
        
        [uid release];
        
    }/* defaultCalendarStore */
    
    returnValue.setReturn(pResult);
}
